[code.Descriptive.Outline]
mainwin 120 40

' PB Syntax JB Fix: INSTR(string1, string2[, starting])
'you can not have two labels together without an operation
'undo last does not return last line entry
'02040608101214161820222426283032343638404244464850525456586062646668707274767880
' Note: Front is Western Courier New regular 10
'       Using Under Score _ try to keep CODE Lines under 80. This allows other
'       reference window; [AA_Convert_PB-JB.log.TXT]; to be used while Coding.
'  ___________________________________________________________________________
' /                                                                           \
'| PB to JB TRANSLATION_AID.BAS                                                |
'| 1. Hugh Polley   2020/02/04                                                 |
'|                                                                             |
'| This code is to be considered "public domain".' Feel free to do what you    |
'| want with it. If you come with an improvement please post it here so all    |
'| Basic users get the benefit.                                                |
'| If you make changes to the CODE add your name and date to above listing!    |
'|                                                                             |
'| Disclaimer:                                                                 |
'| This code is provided as-is and it does not have any warranty of any kind.  |
'| User is responsible for any misuse of the code. Do not use this code in     |
'| whole or in part if you can not accept these terms!                         |
' \___________________________________________________________________________/
'
'  ___________________________________________________________________________
' /                                                                           \
'|Purpose: Translation Code Outline for Power Basic BAS files to Just Basic    |
'|    or: Translation Code Outline for Power Basic BAS files to Python Basic   |
' \___________________________________________________________________________/
'
'  ___________________________________________________________________________
' /                                                                           \
'|       MY PAST TRANSLATE PROGRAMS HAD ONE OR MORE OF THESE METHODS           |
'| NOTE: To Accomplish (1-12) run program again as required after each Step    |
'|01. Get [InFile$=PB_file.bas] from [Load last translation.txt]               |
'|02. Sub Directory [!CONVERT] must already exist                              |
'|03. Program will Place a copy of the pre translated PB code into [!CONVERT]  |
'|04. Program will create an Execution LOG File in CONVERT [BB.PB to JB.log.TXT|
'|05. Program Creates [BB.Scaned-Code.txt] for last update to converted File!  |
'|    NOTE: control what is executed by deleting records from bottom to top!   |
'|06. Change any double spaces to single staces to aid phrase searches         |
'|07. To Aid in searching through Code, keep REM quote + [Space] at the        |
'|    start of each line and a [Space] + REM Quote at end of each line         |
'|08. For each Syntax Change Have Scaned$ = Fixed$, Fixed$=new frepaired file  |
'|    [OPEN Fixed$ FOR OUTPUT] and [OPEN Scaned$ FOR INPUT]                    |
'|09. Highlight lines which need Manual Fix with [< line >]                    |
'|10. For PYTHON Highlight GOTO and Line they branch to with the same Number   |
'|     <## ?? ?> Most can be fixed with DO-LOOP, CASE, IF-THEN-ELSE and/or     |
'|    SUB/FUNCTION routines.                                                   |
'|=============================================================================|
'|Note: Change required GOTO,GOSUB ###, statements that have a value greater   |
'|    than zero! eg. VAL("100") > 0 so change to VAL("Z100") = 0  GOSUB 100    |
'|    becomes GOSUB Z100                                                       |
' \___________________________________________________________________________/
'

on error goto [ErrorHandler]
[SET.and.Assign.GLOBAL.Values]
Err$="[SET.and.Assign.GLOBAL.Values]<"+str$(Skip)+">"
Err0$=Err$
GLOBAL InFile$,CONTROL$,CONVERT$,Fixed$,Scaned$,Skip,Problem,Problem$
GLOBAL Structure, Syntax, Found, Place, Ln, OFFSUB, SUB1OFF, SUB2OFF
GLOBAL f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,f14,f15,f16,f17,f18,f19,f20
'Input-Output File Variables
'______________________________________________________________________________
GLOBAL Type$: Type$="UU.TYPE.variable.TXT" 'open
GLOBAL Dim.As.Type$: Dim.As.Type$="TT.Dim.As.Type.TXT" 'open
GLOBAL Long$: Long$="WW-GLOBAL.Variable.Store.TXT" 'append
GLOBAL Dimed$: Dimed$="SS.Type.Dimed.TXT" 'open

'_______SET_FILE_NUMBERS_____________________________________________
f1=1: f2=2: f3=3: f4=4: f5=5: f6=6: f7=7: f8=8: f9=9: f10=10
f11=11: f12=12: f13=13: f14=14
Place=5: Ln=0 'Size of Reference Numbers!
Skip=0: Found=0 'recording how many procedures
OFFSUB=0: SUB1OFF=0: SUB2OFF=0: Problem=0: dim Problem$(20)
'_______SET_OUTPUT_CONTROLS___________________________________________|
    CONTROL$="!CONTROL\"
    CONVERT$="!CONVERT\"
'______________________________________________________________________________|
[SET.Subdiectory.!CONTROL] Skip=Skip+1
Err$="[SET.Subdiectory.!CONTROL]<"+str$(Skip)+">"
Err1$=Err$
print tab(Ln);Err$
    result = mkdir( "!CONTROL")
    if result <> 0 then
        print "|_____________________________________|"
        print "| [!CONTROL] directory EXISTS !       |"
        print "| Working Directory for .temp Files!  |"
        print "|-------------------------------------|"
    else
        print "|_____________________________________|"
        print "| [!CONTROL] directory CREATED!       |"
        print "| Working Directory for temp Results! |"
        print "|-------------------------------------|"
        print
        Err$= " {{RUN JB Program Again! }}"
        goto [ErrorHandler]
    end if
'______________________________________________________________________________|
[SET.Subdirectory.!CONVERT] Skip=Skip+1
Err$="[SET.Subdirectory.!CONVERT]<"+str$(Skip)+">"
Err2$=Err$
print tab(Ln);Err$
    result = mkdir( "!CONVERT")
    if result <> 0 then
        print "|_________________________________________________|"
        print "| [!CONVERT] directory EXISTS!                    |"
        print "| Working Directory for Translation Files !       |"
        print "|-------------------------------------------------|"
        print
    else
        print "|_________________________________________________|"
        print "| [!CONVERT] directory CREATED!                   |"
        print "| Working Directory for Translation Files !       |"
        print "|-------------------------------------------------|"
        print
        Err$="<error><This is B.PREP> <RUN A.PREP FIRST!><error>"
        Found=Skip-1 'goes to end of program
        goto [ErrorHandler]
    end if
'______________________________________________________________
[SET.From.Translation.txt.BAS.Conversion.File] Skip=Skip+1
Err$="[SET.From.Translation.txt.BAS.Conversion.File]<"+Str$(Skip)+">"
Err3$=Err$ 
print tab(Ln);Err$ 
    ' ____________________________________________________________
    '/Translated Just Basic Code Files                            \
    open "Load Last Translation.TXT" for append as #f1: close #f1
    open "Load Last Translation.TXT" for input as #f2
    '\____________________________________________________________/
        Found=0'number of files found used to avoid translating more than needed
        InFile$="" 'will hold last record in file for procedure Found>skip?
        '____________________________________________________________
        do until eof(#f2)
            input #f2,X$
            IF instr(UPPER$(X$),".BAS")>4 THEN InFile$=X$: Found=Found+1
        loop
     ' ___________________________________________________________
     '/ Last file in Text File with extension of .BAS is used     \
     close #f2
     '\___________________________________________________________/
    if Found<>2 then 'corrupt or empty file
        '________________________________________________________
            cls: print
            Err$="<error>Corrupt [Load Last Translation.TXT] File!<error>"
            print Err$
            print "Files Found=(";Found;") <> 2"
            print "<Last file found: ";X$;">"
            print tab(Ln+4);
            Err$="<There should be two files second one [BB.Name.BAS] File>"
            print Err$
            goto [ErrorHandler]
    else
        [try1START] on error goto [try1CATCH1]
            open CONVERT$+InFile$ for input as #f3: close #f3
            goto [try1END] 'file exists!
        [try1CATCH1] on error goto [try1CATCH2]
            open InFile$ for input as #f4
            open CONVERT$+InFile$ for output as #f5
                do until eof(#f4)
                    line input #f4,Record$
                    print #f5, Record$
                loop
            close #f4
            close #f5
            Err=0: on error  goto [ErrorHandler]
            Err$="SET File: ["+InFile$+"] Loaded into Folder CONVERT!"
            print Err$
            Err$=" { File Error Corrected { RUN JB Program Again! }}"
            goto [ErrorHandler]
        [try1CATCH2] on error goto [ErrorHandler]
            print "< Corrupt [LOAD LAST TRANSLATION.TXT] AS >"
            Err$="<error>[BB.PB File]Not Found in Root Folder!<error>"
            goto [ErrorHandler]
        [try1END] on error goto [ErrorHandler] '!CONVERT Power Basic Program exist
    end if

'______________________________________________________________________________|
[SET.Clear.and.Create.Logfile]  Skip=Skip+1
Err$="[SET.Clear.and.Create.Logfile]<"+str$(Skip)+">"
print tab(Ln);Err$
    ' ___________________________________________________
    '/Create procedure Log File                          \
    open CONVERT$+"BB.PB to JB.log.TXT" for output as #f6
    '\___________________________________________________/
        PRINT #f6,"<"+InFile$+">"
        print #f6, Err0$
        print #f6, Err1$
        print #f6, Err2$
        print #f6, Err3$
        print #f6, Err$
    close #f6
    '\___________________________________________________/

'______________________________________________________________________________|
[SET.Find.Last.PB.bas] Skip=Skip+1
Err$="[SET.Find.Last.PB.bas]<"+str$(Skip)+">"
call logit Err$
print tab(Ln);Err$
    dim info$(1,1) 'dim needed for info to gather file information
    files DefaultDir$+"\!CONVERT", "BB.*.BAS", info$() 'checks for BAS files
    Number=val(info$(0,0))
    '___________________________________________________________
    if Number<>1 then '/Right BAS file not found in Folder?     \
        if Number>1 then Err$="<More than expected [BB.?File?.BAS] In Folder!>"
        if Number<1 then Err$="<BAS File [BB.?File?.BAS] not found!>"
        call logit Err$
        print space$(Ln)+Err$
        print "|_________________________________________________|"
        print "|   Program BUG or OPERATOR ERROR In              |"
        print "|   [!CONVERT] directory                          |"
        print "|-------------------------------------------------|"
        print "| <Where is BB. [";InFile$;"]>"
        print "|_________________________________________________|"
        print
        Err$="<Check to see what happened to [BB.File.BAS]>"
        goto [ErrorHandler]
    end if
'______________________________________________________________________________|
[SET.Check.for.Last.Completed.CODE.Scan] Skip=Skip+1
Err$="[SET.Check.for.Last.Completed.CODE.Scan]<"+str$(Skip)+">"
call logit Err$
print tab(Ln);Err$
    ' ____________________________________________________________
    '/Translated Just Basic Code Files                            \
    open CONVERT$+"BB.Scaned.Code.txt" for append as #f7: close #f7
    open CONVERT$+"BB.Scaned.Code.txt" for input as #f7
    '\____________________________________________________________/
        Found=0'number of files found used to avoid translating more than needed
        Fixed$="" 'will hold last record in file for procedure Found>skip?
        '____________________________________________________________
        do until eof(#f7)
            input #f7,X$ 
            if len(trim$(X$))>0 then Fixed$=X$: Found=Found+1
        loop
        '-----------------------------------------------------------
     close #f7
     '\___________________________________________________________/


    if len(trim$(Fixed$))=0 then
        open CONVERT$+"BB.Scaned.Code.txt" for output as #f8
            print #f8,InFile$ 
        close #f8
        Err$="<PLACED [";InFile$;"] into [BB.Scaned.Code.txt]!>"
        print tab(Ln+4);Err$
        Err$="{{ RUN JB Program Again! }}"
        goto [ErrorHandler]
    else
        print tab(Ln);"Adjusting: ("+Fixed$+") <# Files Found=";Found;">"
    end if

' _____________________________________________________________________________
'/From this point on Fixed$ is used for File output; Scaned$ is used for File  \
'|input, eg. Scaned$=Fixed$, Fixed$=InFile$+##+des.basJ                         |
'|At this point in Code Skip is = 0, Skip/Found controls where you are at in    |
'|Translation Process! Mess with above Code at your own Risk!     |             |
  Skip=0: Err$="< -- > Decreasing number for each adjustment < -- >"
  call logit Err$: print Err$ : Ln=Ln+4
'\_____________________________________________________________________________/

'________________________________________________
[MM.Find.GLOBAL.DIM.AS.String] Skip=Skip+1
Err$="[MM.Find.GLOBAL.DIM.AS.String]<"+str$(Found-Skip)+">"
call logit Err$
print tab(Ln);Err$
If Found>Skip then GOTO [MM.Reconstruct.to.Bracket]
    ' _________________________________________
    '/SETUP Variables                          \
        OFFSUB=0
        Scaned$=Fixed$
        Fixed$=InFile$+".01.AsString.basJ"
    '\_________________________________________/

    ' __________________________________________________________________
    '/open Random file to handle operations without reloading and saving\
    open CONTROL$+Fixed$ for random as #f10 len = 300  'RecordSize
    field #f10, 300 as BasRecord$
        ' ______________________________________________________________
        '/LOAD PB CODE LINES INTO RANDOM ARRAY and get number of records\
        open CONVERT$+Scaned$ for INPUT as #f11: RecordNumber=0
        do until eof(#f11)
            RecordNumber=RecordNumber+1
            line input #f11, BasRecord$: BasRecord$=trim$(lower$(BasRecord$))
            if  left$(BasRecord$,1)<>"'" then BasRecord$="' "+BasRecord$
            if right$(BasRecord$,1)<>"'" then BasRecord$=BasRecord$+" '"
            '==============================================================
            for Rp=1 to 2
                if Rp=1 then Find$=" as string "
                if Rp=2 then Find$=" as long "
                Y1$="": Y3$="": ZZ=1
                '_____________________________________________________________
                do until ZZ=0 '/work loop for multi statements on one line   \
                    ZZ=instr(BasRecord$,Find$,ZZ)'what you are looking for
                    if ZZ>0 then 'found Find$ on line
                        Z1=ZZ: ZZ=ZZ+len(Find$) 'move to next spot on line
                        '________________________________________________________________
                        '/isolate statement part of line                         \
                        zz$=Isolate.Statement$ (Y1$, Y3$, BasRecord$, Z1)
                        '-------------------------------------
                        F$=" global ": Z=instr(zz$,F$)
                        '___________________________________________
                        if Z=1 then '/test for comma global line\
                            q1$="": q2$="": F$=" , ": Z=instr(zz$,F$)
                            if Z>0 then
                                q1$=trim$(left$(zz$,Z))
                                q2$=trim$(mid$(zz$,Z+2))
                                zz$=q1$+" : global "+q2$+space$(1)
                                ZZ=len(Y1$+zz$)
                                Y3$=zz$+trim$(Y3$): zz$=""
                                Z=0: BasRecord$=Isolate.Statement$ (Y1$, Y3$, zz$, Z)
                            end if
                        end if
                    end if
                loop
            next Rp
            '==========================================================
            put #f10,RecordNumber
        loop
        close #f11

        '\______________________________________________________________/
        'RANDOM FILE #F10 IS OPEN
        ' ________________________________________________________________
        '/Find Dim and Redim String STATEMENTS remove AS STRING and repair\
        Find1$=" as ": Find2$="global ": Find3$="string "
        Find$=Find1$+Find2$+Find3$: Find2$=Find1$+Find2$
        '______________________________________
        OFFSUB=0: gosub [SR.Repair.and.Remove.AS.STRING]
        '--------------------------------------
        Find$=Find1$+Find3$: Find2$=""
        '_______________________________________
        OFFSUB=0: gosub [SR.Repair.and.Remove.AS.STRING]
        '---------------------------------------
        Find1$=" as ": Find2$="global ": Find3$="long "
        Find$=Find1$+Find2$+Find3$: Find2$=Find1$+Find2$
       '______________________________________
        OFFSUB=0: gosub [SR.Repair.and.Remove.AS.long]
        '--------------------------------------
        Find$=Find1$+Find3$: Find2$=""
        '_______________________________________
        OFFSUB=0: gosub [SR.Repair.and.Remove.AS.long]
        '---------------------------------------
        Find$=Find1$+"single": Find3$=""
        OFFSUB=0: gosub [SR.Repair.and.Remove.AS.long]
    ' __________________________________________________
    '/Output Repaired Random file to CONVERT$ Folder    \
    open CONVERT$+Fixed$ for output as #f12
        For R=1 to RecordNumber
            get #f10,R : BasRecord$=trim$(lower$(BasRecord$))

            if Left$(BasRecord$,1)<>"'" then BasRecord$="' "+BasRecord$
            if Right$(BasRecord$,1)<>"'" then BasRecord$=BasRecord$+" '"
            print #f12,BasRecord$
       next R
    close #f12
    close #f10
    '\__________________________________________________/

' _________________________________________________
'/ SAVE LAST OUTPUT FILE TO CONTROLING TEXT FILE   \
   call Record.Repaired.Code
'\_________________________________________________/
Err$="{{ RUN JB Program Again! }}"
goto [ErrorHandler]
'_________________________________________________________________________
[SR.Repair.and.Remove.AS.STRING] Ln=Ln+4
Err$="[SR.Repair.and.Remove.AS.STRING]<"+Find$+">"
call logit Err$
print tab(Ln);Err$ 
' __________________________________________________________________
'/Find Global AS String or AS String and fix with $                 \
TypeOff=0
for N=1 to RecordNumber
    get #f10,N : BasRecord$=trim$(lower$(BasRecord$))'fix up found random statement
    '________________________________________________________________
    Y1$="": Y3$="": ZZ=1 '/set peramiters to Opening settings\
    if instr(BasRecord$," type ") then TypeOff=-1: ZZ=0
    if instr(BasRecord$," end type ") then TypeOff=0: ZZ=0
    AraySize$="":ArrayName$="": zz$=BasRecord$
    '_____________________________________________________________
    do until ZZ=0 '/work loop for multi statements on one line   \
        ZZ=instr(BasRecord$,Find$)'what you are looking for
        if ZZ>0 then 'found Find$ on line
        '________________________________________________________________
           '/isolate statement part of line                         \
            BasRecord$=Isolate.Statement$ (Y1$, Y3$, BasRecord$, ZZ)
            '-------------------------------------
                F$=" dim ": Z=instr(BasRecord$,F$)
                if Z=0 then F$=" redim ": Z=instr(BasRecord$,F$)
                if Z=0 then F$=" function ": Z=instr(BasRecord$,F$)
                if Z=0 then
                    if instr(Find$,"global")=0 then
                        F$=" global ": Z=instr(BasRecord$,F$)
                        if Z<>1 then Z=0
                    end if
                end if
                if Z=0 and TypeOff=0 then
                    BasRecord$="<error>no defining statement<error>"+zz$
                    put #f10,N
                    Problem=Problem+1
                    Problem$(Problem)=BasRecord$
                    call logit Problem$(Problem)
                    exit do
                end if

                S1=Z+len(F$) 'move to start of name
                '------------------------------------
                Z0=0
                Z=instr(BasRecord$," ( ",S1): if Z=0 then Z0=instr(BasRecord$,space$(1),S1)
                if Z0>0 then Z=Z0
                if Z=0 then
                    Problem=Problem+1
                    Problem$(Problem)="<error>no space after name?<error>"+zz$
                    BasRecord$=Problem$(Problem)
                    call logit Problem$(Problem)
                    put #f10,N
                    exit do
                end if
                S2=Z
                ArrayName$=trim$(Mid$(BasRecord$,S1,S2-S1+1))
                '-----------------------------------
                Z1=S2+1
                if Z0=0 then
                    Z2=instr(BasRecord$," ) ",Z1)+1
                    AraySize$=space$(1)+trim$(mid$(BasRecord$,Z1,Z2-Z1+1))+space$(1)
                    if len(trim$(AraySize$))=0 then AraySize$=space$(1)
                else
                    AraySize$=space$(1)
                end if
                '-----------------------------------
                Y2$=F$+ArrayName$+AraySize$+Find2$
                BasRecord$=trim$(Y1$)+space$(1)+trim$(Y2$)+space$(1)+Trim$(Y3$)
                ZZ=1
                '----------------------------------
                put #f10,N
                ArrayName$=space$(1)+ArrayName$+space$(1)
                ' _______________________________________
                '/add $ to AS STRING Variable or Function\
                For A=1 to RecordNumber
                    get #f10,A : BasRecord$=trim$(lower$(BasRecord$))
                    Z1=instr(BasRecord$,ArrayName$)
                    if Z1>0 then
                        X$=trim$(left$(BasRecord$,Z1+len(ArrayName$)-1))
                        Y$=trim$(mid$(BasRecord$,Z1+len(ArrayName$)))
                        BasRecord$=X$+"$ "+Y$
                        if A=N then Y2$=BasRecord$
                        put #f10,A
                    end if
                next A
                BasRecord$=Y2$
                Y1$="":Y3$=""
            end if
        loop

    Next N

'=================================================================
Ln=Ln-4: return
'_________________________________________________________________________
[SR.Repair.and.Remove.AS.long] Ln=Ln+4
Err$="[SR.Repair.and.Remove.AS.long]<"+Find$+">"
call logit Err$
print tab(Ln);Err$ 
' __________________________________________________________________
'/Find Global AS String or AS String and fix with $                 \
TypeOff=0
for N=1 to RecordNumber
    get #f10,N : BasRecord$=trim$(lower$(BasRecord$))'fix up found random statement
    '________________________________________________________________
    Y1$="": Y3$="": ZZ=1 '/set peramiters to Opening settings\
    if instr(BasRecord$," type ") then TypeOff=-1: ZZ=0
    if instr(BasRecord$," end type ") then TypeOff=0: ZZ=0
    AraySize$="":ArrayName$="": zz$=BasRecord$
    '_____________________________________________________________
    do until ZZ=0 '/work loop for multi statements on one line   \
        ZZ=instr(BasRecord$,Find$)'what you are looking for
        if ZZ>0 then 'found Find$ on line
        '________________________________________________________________
           '/isolate statement part of line                         \
            BasRecord$=Isolate.Statement$ (Y1$, Y3$, BasRecord$, ZZ)
            '-------------------------------------
                F$=" dim ": Z=instr(BasRecord$,F$)
                if Z=0 then F$=" redim ": Z=instr(BasRecord$,F$)
                if Z=0 then F$=" function ": Z=instr(BasRecord$,F$)
                if Z=0 then F$=" ": if TypeOff=-1 then Z=instr(BasRecord$,F$)
                if Z=0 then
                    if instr(Find$,"global")=0 then
                        F$=" global ": Z=instr(BasRecord$,F$)
                        if Z<>1 then Z=0
                    end if
                end if
                if Z=0 then
                    BasRecord$="<error>no defining statement<error>"+zz$
                    put #f10,N
                    Problem=Problem+1
                    Problem$(Problem)=BasRecord$
                    call logit Problem$(Problem)
                    exit do
                end if

                S1=Z+len(F$) 'move to start of name
                '------------------------------------
                Z0=0
                Z=instr(BasRecord$," ( ",S1): if Z=0 then Z0=instr(BasRecord$,space$(1),S1)
                if Z0>0 then Z=Z0
                if Z=0 then
                    Problem=Problem+1
                    Problem$(Problem)="<error>no space after name?<error>"+zz$
                    BasRecord$=Problem$(Problem)
                    call logit Problem$(Problem)
                    put #f10,N
                    exit do
                end if
                S2=Z
                ArrayName$=trim$(Mid$(BasRecord$,S1,S2-S1+1))
                '------------------------------------
                Z1=S2+1
                if Z0=0 then
                    Z2=instr(BasRecord$," ) ",Z1)+1
                    AraySize$=space$(1)+trim$(mid$(BasRecord$,Z1,Z2-Z1+1))+space$(1)
                    if len(trim$(AraySize$))=0 then AraySize$=space$(1)
                else
                    AraySize$=space$(1)
                end if
                '--------------------------------------
                Y2$=F$+ArrayName$+AraySize$+Find2$
                ZZ=1: BasRecord$=trim$(Y1$)+space$(1)+trim$(Y2$)+space$(1)+Trim$(Y3$)
                '----------------------------------
                Y1$="":Y3$=""
            end if
        loop
        put #f10,N
    Next N
'=================================================================
Ln=Ln-4: return
'_______________________________________
'__________________________________________________
[MM.Reconstruct.to.Bracket] Skip=Skip+1
Err$="[MM.Reconstruct.to.Bracket]<"+str$(Found-Skip)+">"
call logit Err$
print tab(Ln);Err$
If Found>Skip then GOTO [MM.Take.and.repair.GLOBAL]
    ' _________________________________________
    '/SETUP Variables                          \
        OFFSUB=0
        Scaned$=Fixed$
        Fixed$=InFile$+".02.TObracket.basJ"
    '\_________________________________________/

    ' ______________________________________________________
    '/OPEN Files for input and Output                       \
    open CONVERT$+Fixed$ for OUTPUT as #f6
    open CONVERT$+Scaned$ for INPUT as #f5
    '\______________________________________________________/
    do until EOF(#f5)
    '----------------------------------------------------------
        Y1$="": Y3$="": T=0
        line input #f5, xx$: xx$=trim$(xx$): zz$=xx$
        '/Is there quote space?\
        if left$(xx$,1)<>"'" then xx$="' "+trim$(mid$(xx$,2))
        if right$(xx$,1)<>"'" then xx$=trim$(left$(xx$,len(xx$)-1))+" '"
        zz$=xx$ 'for problem$ output
        '_______________________________________________________
        do :Z=0: Z1=0'/work do for multible statement line\
            '____________________________________
            '/Is there a 'TO' inside brackets?  \
            do
                Z=instr(xx$," to ",Z+1)
                if Z>0 then Z1=InsideBrackets(xx$,Z): if Z1>0 then exit do
            loop until Z=0
            '________________________________________________
            if Z>0 then '/TO' found get statement\
                Y1$="": Y3$="": Z2=Z 'store statements
                '/isolate Right of 'TO' statements\
                Z2=instr(xx$," : ",Z2+1) 'Is there statement after to
                if Z2>0 then 'right side of statement found
                '--------------------------------------------------------
                    Y3$=trim$(mid$(xx$,Z2+1)) 'colin divided right side
                    xx$=left$(xx$,Z2)'left remainder with valid Z1 location
                else
                    if len(Y3$)=0 then Y3$=" '" 'no right side statements
                    '--------------------------------------------------------
                end if
                '_______________________________________________
                '/isolate Left of 'TO' statements\
                Z2=0:Lc=0
                do 'move right along line seperate left statements
                '----------------------------------------------------------------
                    Z2=instr(xx$," : ",Z2+1): if (Z2<Z and Z2>Lc) then Lc=Z2 'colin location
                '----------------------------------------------------------------
                loop until Z2=0
                if Lc>0 then 'Isolate left colin statement
                '------------------------------------------------------
                    Y1$=trim$(Left$(xx$,Lc+1)) 'left side to colin
                    xx$=trim$(mid$(xx$,Lc+2)) 'right side from colin
                '-----------------------------------------------
                else
                '----------------------------------------------
                    if Len(Y1$)=0 then Y1$="' " 'no left side statements
                '-----------------------------------------------
                end if
                if left$(xx$,1)="'" then xx$=trim$(mid$(xx$,2))
                if right$(xx$,1)="'" then xx$=trim$(left$(xx$,len(xx$)-1))
                xx$=space$(1)+xx$+space$(1)
                '_____________________________________________________
                '  /move along XX$ to bracket, then to, extract first
                Z1=instr(xx$," ( ")+1
                '______________________________________________________
                Z3=instr(xx$,"$ , ")'/String operation ?\
                if Z3>0 then Z3=Z3+3: Z1=Z3
                Z1$=left$(xx$,Z1) 'take out xx$ --> (
                xx$=mid$(xx$,Z1+1) 'xx$ after first bracket
                Z1=instr(xx$," to ")
                X1$=trim$(left$(xx$,Z1))
                xx$=mid$(xx$,Z1+3)
                Z2=instr(xx$," ) ")
                X2$=trim$(left$(xx$,Z2))
                xx$=mid$(xx$,Z2+1)
                if Z3>0 then 'string operation
                    X3$=X1$+" , "+X2$+" - "+X1$+" + 1"
                else 'not a string operation
                    X3$=X2$+"-"+X1$
                end if
                Y1$=trim$(Y1$)+space$(1)
                Y3$=space$(1)+trim$(Y3$)
                Y1$=Y1$+Z1$+space$(1)+X3$+space$(1)+trim$(xx$)
                xx$="": if Y3$<>" '" then xx$=Y3$: Y3$=""
                T=1
           end if
        loop until Z=0
        xx$=Y1$+xx$+Y3$
        print #f6,xx$
    '----------------------------------------------------------------
    loop
   ' _________________
   '/Close OPEN Files \
        close #f6
        close #f5
   '\________________/

' _________________________________________________
'/ SAVE LAST OUTPUT FILE TO CONTROLING TEXT FILE   \
   call Record.Repaired.Code
'\_________________________________________________/

'Record repair not working
Err$="{{ RUN JB Program Again! }}"
goto [ErrorHandler]

[MM.Take.and.repair.GLOBAL] Skip=Skip+1
Err$="[MM.Take.and.repair.GLOBAL]<"+str$(Found-Skip)+">"
call logit Err$
print tab(Ln);Err$
If Found>Skip then GOTO [MM.Extract.and.Store.TYPE]
    ' __________________________________________________
    '/SETUP Variables                                   \
        OFFSUB=0
        Scaned$=Fixed$
        Fixed$=InFile$+".03.AsGlobal.basJ"
    '\__________________________________________________/
    ' ______________________________________________________
    '/OPEN Files for input and Output                       \
        open CONVERT$+Long$ for append as #f9
        print #f9,"'-------[Take.and.repair.GLOBAL]---------"
        open CONVERT$+Fixed$ for OUTPUT as #f14
        open CONVERT$+Scaned$ for INPUT as #f13
    '\______________________________________________________/

    '---------------------
    Remove$=" as global "
    '---------------------
    ' ________________
    '/                \
    do until EOF(#f13)
        line input #f13, xx$: xx$=lower$(trim$(xx$)): zz$=xx$
        do 'work loop to check whole line
            Z3=instr(xx$,Remove$)
            '________________________________________________
            if Z3>0 then '/    as global found             \
            '------------------------------------------------
                Z=Z3: Z3=Z3+len(Remove$)-1
                xx$=Isolate.Statement$ (Y1$, Y3$, xx$, Z)
                '____________________________________________
                Find$=" dim ": Z=instr(xx$,Find$)
                if Z=0 then Find$=" redim ": Z=instr(xx$,Find$)
                if Z=0 then Find$=" function ": Z=instr(xx$,Find$)
                if Z=0 then 'isolate PB Code Error
                '----------------------------------------------
                    Problem=Problem+1
                    Err$="<error>No Definition<error>"+zz$
                    Problem$(Problem)=Err$
                    call logit Problem$(Problem)
                    Y3$=Problem$(Problem)+space$(1)+Y3$
                    yy$="": Z3=0 'signal to exit
                    xx$=Isolate.Statement$ (Y1$, Y3$, yy$, 0)
                '__________________________________________
                else '/ remove and store AS GLOBAL\
                    Z1=Z+len(Find$) 'start of Name
                    Z2=instr(xx$,Space$(1),Z1)
                    Nm$=mid$(xx$,Z1,Z2-Z1)
                    print #f9,Nm$   'name recorded to Global File
                    '---------------------------------------------
                    Z1=instr(xx$,Remove$)
                    Z2=len(Remove$)+Z1
                    After$=trim$(mid$(xx$,Z2))
                    if len(After$)>0 then After$=" as "+After$+" "
                    Y3$=space$(1)+trim$(left$(xx$,Z1))+space$(1)+After$+trim$(Y3$)
                    yy$=""
                    xx$=Isolate.Statement$ (Y1$, Y3$, yy$, 0)
                end if
            end if
        loop until Z3=0 'check complete line loop
        '___________________________
        '/save inspected line\
        print #f14,xx$ 'output checked Record
    loop
   '\________________/
   ' _________________
   '/Close OPEN Files \
        close #f13
        close #f14
        close #f9
   '\________________/
' __________________________________________________
'/ SAVE LAST OUTPUT FILE TO CONTROLING TEXT FILE    \
   call Record.Repaired.Code
'\__________________________________________________/
Err$="{{ RUN JB Program Again! }}"
goto [ErrorHandler]

'_________________________________________________________________
[MM.Extract.and.Store.TYPE] Skip=Skip+1
Err$="[MM.Extract.and.Store.TYPE]<"+str$(Found-Skip)+">"
call logit Err$
print tab(Ln);Err$
If Found>Skip then GOTO [MM.Use.Random.Create.Type.Files]
    ' _________________________________________
    '/SETUP Variables                          \
        OFFSUB=0
        Scaned$=Fixed$
        Fixed$=InFile$+".04.Type.basJ"
    '\_________________________________________/

    ' ______________________________________________________
    '/OPEN Files for input and Output                       \

    open CONVERT$+Type$ for output as #f15
    open CONVERT$+Fixed$ for OUTPUT as #f16
    open CONVERT$+Scaned$ for INPUT as #f17
    '\______________________________________________________/
    Remove1$=" type ": Remove2$=" end type ": Z3=-1: Field$="" 'hunt for type else process type
    ' _________________________________________________________
    do until EOF(#f17)
    '----------------------------------------------------------
        line input #f17, xx$: xx$=trim$(xx$)
        zz$=xx$ 'for problem$ output
        do 'line work loop
            ' ______________________________________________________
            '/Does TYPE command on line exist?                      \
            if Len(Field$)=0 then Z=instr(xx$,Remove1$) else Z=1 'Z3 process indicator
            '________________________________________________
            if Z>0 then '/ save TYPE to file Type$ \
                '______________________________________________________________
                if Len(Field$)=0 then'/ Does string name Nm$ from xx$ exist?\
                    xx$=Isolate.Statement$ (Y1$, Y3$, xx$, Z)
                    Z1=instr(xx$,Remove1$)+len(Remove1$) 'Does string name exist?
                    Nm$=trim$(mid$(xx$,Z1)): xx$="" 'Type name assigned to Nm$
                    if len(trim$(Nm$))=0 then  'no name report error
                        Problem=Problem+1
                        Problem$(Problem)="<Error><"+Remove1$+">Name not found!<error>"+zz$
                        call logit Problem$(Problem)
                        exit do
                    end if
                    Field$=Nm$
                    Z=1: Y3$=trim$(Y3$): xx$=trim$(Y3$): Y3$=""
                end if
                '<---Continue getting Type Variables till xx$=end type --->
                do  'unless there is bad data there will be Variables
                    if xx$="'" then exit do
                    xx$=Isolate.Statement$ (Y1$, Y3$, xx$, Z)
                   '_____________________________________________
                    if xx$=Remove2$ then'/Type Saved and Removed\
                        Z3=-1: xx$="": Z=0 'reconfigure XX$
                        if Len(Field$)=Len(Nm$) then
                            Problem=Problem+1
                            Problem$(Problem)="<error>No Field Variables<error>"+zz$
                            call logit Problem$(Problem)
                            exit do
                        end if
                        print #f15,Field$: Field$=""
                        xx$=Isolate.Statement$ (Y1$, Y3$, xx$, Z)'combine left over
                        exit do
                    '_____________________________________
                    else '/Accumulate Type Variables\
                        Sz=instr(xx$,"*"): Sz$=""
                        if Sz>0 then
                            Sz$=trim$(mid$(xx$,Sz+1))
                            xx$=Left$(xx$,Sz-1)
                        end if
                        if Sz=0 then Sz$="5"
                        Var$=trim$(xx$)
                        Field$=Field$+","+Sz$+","+Var$

                        xx$=Y3$: Y3$="": Z=1:
                     end if
                     if trim$(xx$)="'" and trim$(Y1$)="'" then
                        xx$="": Y1$="": exit do
                    else
                        if trim$(xx$)="'" then
                            xx$=Isolate.Statement$ (Y1$, Y3$, xx$, Z)'combine left over
                            exit do
                        end if
                    end if
                loop until trim$(Y1$)="" 'xx$ has all the line
                Z=0 'exit do for new line



            end if

        loop until Z=0
        if xx$<>"'" and len(xx$)>0 then print #f16,xx$ : xx$=""
    loop
   ' _________________
   '/Close OPEN Files \
        close #f17
        close #f16
        close #f15
   '\________________/

' _________________________________________________
'/ SAVE LAST OUTPUT FILE TO CONTROLING TEXT FILE   \
   call Record.Repaired.Code
'\_________________________________________________/

Err$="{{ RUN JB Program Again! }}"
goto [ErrorHandler]
'_________________________________________________
[MM.Use.Random.Create.Type.Files] Skip=Skip+1
Err$="[MM.Use.Random.Create.Type.Files]<"+str$(Found-Skip)+">"
call logit Err$
print tab(Ln);Err$
If Found>Skip then GOTO [MM.Repair.FOR.RANDOM]
    ' _________________________________________
    '/SETUP Variables                          \
    OFFSUB=0
    Scaned$=Fixed$
    Fixed$=InFile$+".05.DimType.basJ"
    '\_________________________________________/
    ' __________________________________________________________________
    '/open Random file to handle operations without reloading and saving\
    open CONTROL$+Fixed$+".rnd" for random as #f18 len = 300  'RecordSize
        field #f18, 300 as BasRecord$
        ' ______________________________________________________________
        '/LOAD PB CODE LINES INTO RANDOM ARRAY and get number of records\
        open CONVERT$+Scaned$ for INPUT as #f19: RecordNumber=0
        do until eof(#f19)
            RecordNumber=RecordNumber+1
            line input #f19, BasRecord$: BasRecord$=trim$(BasRecord$)
            put #f18,RecordNumber
        loop
        close #f19
        '\______________________________________________________________/

        '__________________________________________________________________
        Ln=Ln+4: gosub [SR.Save.DIM.for.TYPE.Variable]:Ln=Ln-4'Recorded to text file
        '__________________________________________________________________
        Ln=Ln+4: gosub [SR.ReName.TYPE.to.Variable]:Ln=Ln-4'Recorded in text file
        ' __________________________________________________
        '/Output Repaired Random file to CONVERT$ Folder    \
        open CONVERT$+Fixed$ for output as #f12
            For R=1 to RecordNumber
                get #f18,R : BasRecord$=trim$(lower$(BasRecord$))
                if Left$(BasRecord$,1)<>"'" then BasRecord$="' "+BasRecord$
                if Right$(BasRecord$,1)<>"'" then BasRecord$=BasRecord$+" '"
                print #f12,BasRecord$
            next R
        close #f12
    close #f18
    '\__________________________________________________/

' _________________________________________________
'/ SAVE LAST OUTPUT FILE TO CONTROLING TEXT FILE   \
   call Record.Repaired.Code
'\_________________________________________________/

Err$="{{ RUN JB Program Again! }}"
goto [ErrorHandler]
'\______________________________________________________________________/
[SR.ReName.TYPE.to.Variable]
Err$="[SR.ReName.TYPE.to.Variable]<"+str$(Found-Skip)+">"
call logit Err$
print tab(Ln);Err$

    'get: From File Type$: TypeName$
    'save to FieldVar.tmp: Field Names
    'find TypeName$ and add FieldName$ to it
    '_______________________________________________________
    '/load type save any Dim of Type Name                   \
    open CONVERT$+Type$ for append as #f1: close #f1
    open CONVERT$+Type$ for input as #f1
    '\______________________________________________________/
    do until eof(#f1)
        line input #f1,TypeLine$
        '__________________________________________
        '  / Extract CSV Elements from Typeline \
        open CONTROL$+"temp.temp" for output as #f2
            print #f2,TypeLine$
        close #f2
        open CONTROL$+"temp.temp" for input as #f2
            input #f2,TypeName$
            TypeName$=trim$(TypeName$)
            X$=""
            do until eof(#f2)
                input #f2,Size,Name$
                X$=X$+","+trim$(Name$)
            loop
        close #f2
        X$=mid$(X$,2)
        '___________________________________
        ' / Save Typeline element Names \
        open CONTROL$+"temp.temp" for output as #f2
            print #f2,X$
        close #f2
        '_______________________________________________________________
        ' /Get Dimed Type Variables \
        open CONVERT$+Dim.As.Type$ for input as #f3
        do until eof(#f3)
        '================================================================
            input #f3,Var$,Typ$ 'Variable and Type name
            '-------------------------------------------
            if Typ$=TypeName$ then
            '-------------------------------------
                Z=instr(Var$," ( ")
                if Z>0 then Var$=space$(1)+trim$(left$(Var$,Z))+space$(1)
                '_____________________________________________________
                ' /Add to Var$, Field$ from Temp.temp \
                For N=1 to RecordNumber '/Hunt for Type Dim Statement\
                '=====================================================
                    get #f18,N : BasRecord$=trim$(BasRecord$)
                    Z=instr(BasRecord$,Var$): Y3$=""
                    '__________________________________________________
                    if Z>0 then '/Variable found process\
                    do until trim$(Y3$)="'"
                    '===================================================
                        xx$=Isolate.Statement$ (Y1$, Y3$, BasRecord$, Z)
                        '________________________________________________________
                        Z=instr(xx$,Var$)'/Is there a Type Dim Variable on line?\
                        '_____________________________________________________________
                        if (Z>0) and (instr(xx$," open ")=0) then'/not a len Type dim\
                        '-------------------------------------------------------------
                            Z1=instr(xx$,Var$)
                            Y0$=left$(xx$,Z1)'before Type Dim Var
                            Z1=Z1+len(Var$)
                            Z2=instr(xx$," .",Z1)
                            '_____________________________________________________
                            if Z2>0 then '/ Reform Dimed Type Field Variable   \
                            '-----------------------------------------------------
                                Z3=instr(xx$,space$(1),Z2+1)
                                Y3$=Y0$+(trim$(Var$)+trim$(mid$(xx$,Z2,Z3-Z2))+_
                                space$(1)+mid$(xx$,Z1,Z2-Z1))+Mid$(xx$,Z3)
                                xx$=""
                                BasRecord$=Isolate.Statement$ (Y1$, Y3$, xx$, Z)
                                put #f18,N
                            else
                            '------------------------------------------------------
                                '/Create Put or Get Dimed Variables\
                                if instr(Y0$," put ") or instr(Y0$," get ") then
                                '-----------------------------------------------
                                    Y0$=trim$(Y0$): Y0$=trim$(left$(Y0$,len(Y0$)-1))
                                    Y0$=space$(1)+Y0$+Space$(1)
                                    Z=instr(Y0$," , ")+1
                                    Num$=trim$(mid$(Y0$,Z+2))

                                    '__________________________________________
                                    ' /Type Variable name List\
                                    open CONTROL$+"temp.temp" for input as #f2
                                        if instr(Y0$," put ") then
                                        '-------------------------
                                            R$=""
                                            do until eof(#f2)
                                            '-----------------
                                                input #f2,X$
                                                R$=R$+space$(1)+X$+" = "+_
                                                trim$(Var$)+"."+X$+" ( 0 ) : "
                                            '-----------------
                                            loop
                                            R$=R$+Y0$
                                            Y3$=R$+Y3$: xx$=""
                                            BasRecord$=Isolate.Statement$ (Y1$, Y3$, xx$, Z)
                                            put #f18,N
                                        '-------------------------
                                        end if

                                        if instr(Y0$," get ") then
                                        '-------------------------
                                            R$=""
                                            do until eof(#f2)
                                                input #f2,X$
                                                R$=R$+" : "+trim$(Var$)+"."+X$+" ( 0 ) = "+X$
                                            loop
                                            R$=Y0$+R$
                                            Y3$=R$+Y3$: xx$=""
                                            BasRecord$=Isolate.Statement$ (Y1$, Y3$, xx$, Z)
                                            put #f18,N
                                        '--------------------------
                                        end if
                                    close #f2
                                    '\_________________________________/
                                    exit do
                                '------------------------------------------------
                                else
                                '------------------------------------------------
                                    Problem=Problem+1
                                    Problem$(Problem)="<error>PB Random Var<error>"+BasRecord$
                                    BasRecord$=Problem$(Problem)
                                    call logit BasRecord$
                                    put #f18,N
                                    exit do
                                '--------------------------------------------------
                                end if
                            '------------------------------------------------
                            end if
                        '-------------------------------------------------
                        end if
                    '=====================================================
                    loop
                    end if
                '=========================================================
                next N
            '--------------------------------------------------------------
            end if
        '==================================================================
        loop
        close #f3
    '=======================================================================
    loop
    close #f1
return
'_____________________________________
[MM.Repair.FOR.RANDOM] Skip=Skip+1
Err$="[MM.Repair.FOR.RANDOM]<"+str$(Found-Skip)+">"
call logit Err$
print tab(Ln);Err$
If Found>Skip then GOTO [MM.Cleanup.and.Save.Changes]
[Info.MM.Repair.FOR.RANDOM]
'input: Scaned$ 'For Random',CONVERT$+Dim.As.Type$
'out: From 'For Random'
'get: LenVar$, Y1$, Y2$, Y3$, FileNumber$ 
'Hunt: From 'CONVERT$+Dim.As.Type$', LenVar$=>TypeVar$, TypeVar$=>DimVar$
'get: From DimVar$, DimVar$ name, Dim peramiter V
'get: From CONVERT$+Type$, TypeVar$=>Field$=>Fixed$, Gbl$=>CONVERT$+Long$
'get: From CONVERT$+Type$, DimVar$ & Fld$ => Array$(Array)

    ' _________________________________________
    '/SETUP Variables                          \
        OFFSUB=0
        Scaned$=Fixed$
        Fixed$=InFile$+".06.ForRandom.basJ"
    '\_________________________________________/

    ' ______________________________________________________
    '/OPEN Files for input and Output                       \
        open CONVERT$+Fixed$ for OUTPUT as #f6
        open CONVERT$+Scaned$ for INPUT as #f5
        open CONVERT$+Long$ for append as #f4
        print #f4,"'---[MM.Repair.FOR.RANDOM]----"
    '\______________________________________________________/
    Find1$=" for random ": Find2$=" len = len ( "
   ' ________________
   '/                \
    do until EOF(#f5)
        line input #f5, xx$: zz$=xx$
        Z=instr(xx$,Find1$)'Is  xx$ open Random file?
        '___________________________________________________
        If Z>0 then '/ Isolate Random LenVar \
            Y1$="": Y3$="" 'open for random as 4 Len=Len( LenVar$ )
            xx$=Isolate.Statement$ (Y1$, Y3$, xx$, Z)
            Z=instr(xx$,Find2$,Z)
            Y2$=trim$(Left$(xx$,Z)) 'open for random as 4
            Zx=instr(Y2$," as ")+3
            FileNumber$=trim$(mid$(Y2$,Zx))'4
            Y2$=trim$(left$(Y2$,Zx))+" #"+FileNumber$+" len = "
            Z1=Z+len(Find2$)
            Z2=instr(xx$," ) ",Z1)
            LenVar$=trim$(mid$(xx$,Z1,Z2-Z1))'Len=Len( LenVar$ )
            '__________________________________________
            '  /find LenVar Type Name\
            TypeVar$=""  'UU.TYPE.variable.TXT
            open CONVERT$+Dim.As.Type$ for input as #f7
                do until eof(#f7)
                    input #f7,X$,Y$
                    if trim$(X$)=LenVar$ then TypeVar$=trim$(Y$)
                loop
            close #f7
            '____________________________________________________
            if Len(TypeVar$)=0 then
                Problem=Problem+1
                Problem$(Problem)="<error>Random Len Dummy<error>"+zz$
                call logit Problem$(Problem)
            '____________________________________________________
            else '/Find Type Dim Var Name\
                DimVar$=""
                open CONVERT$+Dim.As.Type$ for input as #f7
                    do until eof(#f7)
                        input #f7,X$,Y$
                        if trim$(Y$)=TypeVar$ then DimVar$=trim$(X$)
                    loop
                close #f7
                '________________________________________________
                '/Find Type Dim Variable to hold Field Variables\
                open CONVERT$+Dimed$ for output as #f10
                If len(DimVar$)>0 then
                '-------------------------------------------------
                    V=0: Z1=instr(DimVar$," ( ")
                    if Z1>0 then Z2=instr(DimVar$," )",Z1)-1
                    '____________________________________________
                    if Z2>0 then '/Dim size Found\
                            Z3=Z1: Z1=Z1+2
                            V$=mid$(DimVar$,Z1,Z2-Z1+1)
                            V=val(V$)
                            DimVar$=trim$(left$(DimVar$,Z3))
                    end if
                    '____________________________________________
                    '/look for Field Variables         \                                          \
                    open CONVERT$+Type$ for input as #f8
                    do until eof(#f8)
                     '--------------------------------------------
                        line input #f8,X$: X$=trim$(X$)
                        '----------------------------------------------
                        open CONTROL$+"Temp.Temp" for output as #f9
                            print #f9,X$ 'csv
                        close #f9
                        '---------------------------------------------
                        open CONTROL$+"Temp.Temp" for input as #f9
                        '--------------------------------------------
                            input #f9,Y$: Y$=trim$(Y$)
                            Field$="field #"+FileNumber$
                        '_______________________________________________
                        if TypeVar$=Y$ then'/Type Field Variables Found\
                            Sum=0
                            do until eof(#f9)
                            '-----------------------------------------------
                                input #f9,Sz$,Fld$
                                Sum=Sum+val(Sz$)
                                Gbl$=DimVar$+"."+Fld$
                                print #f4,Gbl$
                                Field$=Field$+","+Sz$+" as "+Fld$
                                Dv$= " DIM "+DimVar$+"."+Fld$+"("+str$(V)+")" '+","+Sz$
                                print #f10,Dv$

                            '-------------------------------------------
                            loop
                            if Sum=0 then Sum$="<error>" else Sum$=str$(Sum)
                            Y2$=Y2$+space$(1)+Sum$
                            Field$="' "+Field$+" '"
                        '--------------------------------------------------
                        end if
                        close #f9
                        '--------------------------------------------------
                    loop
                    close #f8
                end if
                close #f10
                '------------------------------------------------------
            end if
            '-------------------------------------------------------------
            Y3$=Y2$+space$(1)+trim$(Y3$): xx$="": Z=0 'reform line to Y3$
            xx$=Isolate.Statement$ (Y1$, Y3$, xx$, Z)

            '-------------------------------------------------------------
        end if

        if len(Field$)>0 then
            print #f6,"'' <--------------<New Code>-----------------> ''"
            print #f6,xx$
            print #f6,Field$
            print #f6,"'' <------<After Repaired Random Code>-------> ''"
        else
            print #f6,xx$

        end if
        Field$=""
    loop
   '\________________/
   ' _________________
   '/Close OPEN Files \
    close #f4
    close #f5
    close #f6
   '\________________/

[here.working] Print "[here.working] stop": stop
' __________________________________________________
'/ SAVE LAST OUTPUT FILE TO CONTROLING TEXT FILE    \
   call Record.Repaired.Code
'\__________________________________________________/
Err$="{{ RUN JB Program Again! }}"
goto [ErrorHandler]
'_____________________________________________________
[SR.Save.DIM.for.TYPE.Variable]
Err$="[SR.Save.DIM.for.TYPE.Variable]<"+str$(Found-Skip)+">"
call logit Err$
print tab(Ln);Err$
    '_______________________________________________________
    '/load type save any Dim of Type Name                   \
    open CONVERT$+Dim.As.Type$ for output as #f4: close #f4
    open CONVERT$+Type$ for input as #f1
    open CONVERT$+Dim.As.Type$ for output as #f2
    '\______________________________________________________/
    do until eof(#f1)
        line input #f1,TypeName$
        open CONTROL$+"temp.temp" for output as #f3
            print #f3,TypeName$
        close #f3
        open CONTROL$+"temp.temp" for input as #f3
            input #f3,TypeName$
        close #f3
        TypeName$=space$(1)+trim$(TypeName$)+space$(1)
        '_____________________________________________________
        For N=1 to RecordNumber '/Hunt for Type Dim Statement\
            get #f18,N : BasRecord$=trim$(BasRecord$)
            Dim$=" dim ": Z=instr(BasRecord$,Dim$)
            If Z=0 then Dim$=" redim ": Z=instr(BasRecord$,Dim$)
            if Z>0 then Z=instr(BasRecord$," as"+TypeName$)
            if Z>0 then
                Y1$="": Y3$="": xx$=BasRecord$
                xx$=Isolate.Statement$ (Y1$, Y3$, xx$, Z2)
                Z1=instr(BasRecord$,Dim$)+len(Dim$)-1
                Z2=instr(BasRecord$," as"+TypeName$)
                Dummy$=mid$(xx$,Z1,Z2-Z1-1)

                open CONVERT$+Dim.As.Type$ for append as #f4
                    print #f4,trim$(Dummy$)+","+trim$(TypeName$)
                close #f4
                '/eliminate the dim as it is recorded\
                If len(Trim$(Y3$))>1 then
                    Y3$=trim$(Y3$)
                    if left$(Y3$,1)=":" then Y3$=trim$(mid$(Y3$,2))
                end if
                BasRecord$=Y1$+space$(1)+Y3$
                put #f18,N
            end if
        next N
    loop
    '____________
    '/          \
    close #f1
    close #f2
    '\__________/
return

[aa.working3]
'OPEN y1$ FOR RANDOM AS 2 LEN = LEN(DUMMYpick)
'        picked(0).pk1 = a
'        picked(0).pk2 = b
'        picked(0).pk3 = c
'        picked(0).pk4 = d
'        picked(0).pk5 = e
'        picked(0).pk6 = f
'        PUT#2, six, picked(0)
'CLOSE 2
'definition of a User-Defined Type begins with the reserved word TYPE
'and ends with the keywords END TYPE.  In between, you define the names
'and of the member elements (fields) that are to be part of the new Type.
'For example:
'DIM Student AS StudentRecord
'TYPE StudentRecord
'LastName     AS STRING * 20 ' A 20-character string
'FirstName    AS STRING * 15 ' A 15-character string
'IDnum        AS LONG        ' Student ID, a Long-integer
'Contact      AS STRING * 30 ' Emergency contact person
'ContactPhone AS STRING * 14 ' Their phone number
'ContactRel   AS STRING * 8  ' Relationship to student.
'AverageGrade AS SINGLE      ' Single-precision % grade
'END TYPE

'Remember that the definition of a User-Defined Type does not set aside memory for
'storing data of that Type.  Rather, it defines a template for the new
'Type StudentRecord.  Then when the compiler encounters a statement declaring
'(or creating) a variable of the new Type, it will "know" how many bytes
'of storage to set aside for the variable.  In order to use this new Type,
'you must declare variables of that Type with the DIM statement:
'DIM Student AS StudentRecord

'________________________________________________________
[MM.Next.Operation.END] 'place new operations after this line
'========================================================
'________________________________________________________________
junk=0 'needed to prevent weird syntax error when two Labels meet
goto [ErrorHandler]
'_____________________________________
[MM.LABEL.FORM]
Err$="[MM.LABEL.FORM]<"+str$(Found-Skip)+">"
call logit Err$
print tab(Ln);Err$

If Found>Skip then GOTO [MM.Next.Operation.END]
    ' _________________________________________
    '/SETUP Variables                          \
        OFFSUB=0
        Scaned$=Fixed$
        Fixed$=InFile$+".00.empty.basJ"
    '\_________________________________________/
    ' ______________________________________________________
    '/OPEN Files for input and Output                       \
        open CONVERT$+Fixed$ for OUTPUT as #f6
        open CONVERT$+Scaned$ for INPUT as #f5
    '\______________________________________________________/

   ' ________________
   '/                \
    do until EOF(#f5)
        line input #f5, xx$



    loop
   '\________________/
   ' _________________
   '/Close OPEN Files \
        close #f5
        close #f6
   '\________________/
[Form.Guard]
Err$="[Form.Guard] Program should not reach here after [MM.Next.Operation.END]"
goto [ErrorHandler]
' __________________________________________________
'/ SAVE LAST OUTPUT FILE TO CONTROLING TEXT FILE    \
   call Record.Repaired.Code
'\__________________________________________________/
Err$="{{ RUN JB Program Again! }}"
goto [ErrorHandler]

[MM.Cleanup.and.Save.Changes] Ln=0
Err$="[MM.Cleanup.and.Save.Changes]<"+str$(Found-Skip)+">"
call logit Err$
print tab(Ln);Err$
' ______________________________________________________
'/END OF THIS PROGRAM, MORE STRUCTURAL WORK NEEDED BE IT\
'|FOR EITHER PYTHON OR JUST BASIC, DO NOT RUN AS EXE, IT |
'|IS CONSTRUCTED TO FIX CODE PROBLEMs AS ENCOUNTERED NEXT|
'|LOAD: [B-prep_Code TranslatePB-jb.basJ] to Continue    |
'|making changes to the PB code. It will use             |
'|[??.Scaned.Code.txt] to capture the PB File Name.      |
'========================================================

'______________________________________________________________________________|
print "  _____________________________________________________  "
print " / Preparation for Next Translating Code Complete!     \ "
print "| TO CONTINUE TRANSLATING Power Basic, Load into the    |"
print "| JUST BASIC Editor [BB-prep_Code Translate PB-jb.basJ] |"
print "| Then RUN Program in Editor                            |"
print " \_____________________________________________________/ "
print
print "Load and get base name add CC to front"
' __________________________________________
'/Setup files for saving completed prep AA  \
Scaned$=CONVERT$+Fixed$
Fixed$="CC."+InFile$
open "Load Last Translation.TXT" for append as #1
    print #1, Fixed$
close #1
'\__________________________________________/
   ' ___________________________________________________________________
   '/Save prepared file to Main Folder                                  \
      open Fixed$ for OUTPUT as #11
      open Scaned$ for INPUT as #10
    '\__________________________________________________________________/
   ' __________________________________________________________________
   '/Find Globals,output, then input, then save as single Global       \
     do until eof(#10)
        line input #10,xx$
        print #11,xx$
    loop
   ' _________________
   '/Close OPEN Files \
      close #10
      close #11
   '\_________________/
    '___________________________________________________________________
    [CONVERT.KILL.BASJ.FILES]
    dim info$(1,1) 'dim needed for info to gather file information
    files DefaultDir$+"\!CONVERT", "*.BASJ", info$() 'checks for BAS files
    Number=val(info$(0,0))
    if Number>0 then
        for F=1 to Number
            kill CONVERT$+info$(F,0)
        next F
    end if

'_________________________________________________________
[ErrorHandler] 'NOTIFICATION OF END OF EXECUTION OR ERROR \
'\__Place SUB OR FUNCTION CALLS here only when no error!__/
    Ln=0
    if Err>0 then
        print
        print " ___________________________________________"
        print "/          ERROR MESSAGE                    "
        if Err$<>"" then print "{"+Err$+"}"
        print "Error number is {";Err;"}"
        print "\__________END OF MESSAGE___________________"
    else
        print
        print " ___________________________________________"
        print "/          LAST PROCEDURE                   "
        print " {"+Err$+"}"
        print "\___________OR MESSAGE______________________"

       if Found>Skip then
            call logit "BB [END OF PROGRAM EXECUTION]"
            print " ___________________________________________"
            print "/          OUTPUTED FILE                   "
            print "   Program has Returned the Checked"
            print "   Code to Program ["+Fixed$+"]"
            print "\______________THE_END______________________"
        end if
    end if
    if Problem>0 then
        print " ___________________________________________"
        print "/          Code Problems Found              "
        print "   Some Code translations Failed!           "
        print "   See [BB.PB to JB.log.TXT]                "
        print "\________ Problem _ List ___________________"
        print
        for X=1 to Problem
            print tab(4);Problem$(X)
        next X
    end if


' __________________________________________________________________
'/  PROPER END TO PROGRAM EXECUTION AND ERROR HANDLING              \
                    END                                             '|
'|  3 RETURN without GOSUB                                           |
'|  4 Read past end of data                                          |
'|  8 Branch label not found                                         |
'|  9 Subscript out of range                                         |
'|  11 Division by zero                                              |
'|  53 OS Error: The system cannot find the file specified.          |
'|  58 OS Error: Cannot create a file when that file already exists. |
'|  55 Error opening file                                            |
'|  52 Bad file handle                                               |
'|  62 Input past end of file                                        |
'|                                                                   |
'\____________START OF FUNCTIONS AND SUBROTINES______________________/
'=====================================================================
'____________________________________________________
sub Record.Repaired.Code 'Fixed,CONVERT$ are Global
' __________________________________________________
'/Save to Controlling Text File                     \
open CONVERT$+"BB.Scaned.Code.txt" for append as #21
    print #21,Fixed$ 'last file created or repaired
close #21
'\__________________________________________________/
end sub
'__________________________
[LOGtoCONTROLprocessedFILE]
sub logit itlog$
    itlog$=trim$(itlog$)
    open CONVERT$+"BB.PB to JB.log.TXT" for APPEND as #22
        print #22,SPACE$(Ln)+itlog$
    close #22
end sub
'_______________________
function Ltrim$(String$)
    do until String$=Trim$(String$)
        if trim$(String$)="" then String$="": exit do
        If left$(String$,1)=space$(1) then String$=mid$(String$,2) else exit do
    loop
    Ltrim$=String$
end function
'_______________________
function Rtrim$(String$)
    do until String$=Trim$(String$)
        if trim$(String$)="" then String$="": exit do
        If Right$(String$,1)=space$(1) then
            String$=mid$(String$,1,len(String$)-1)
        else
            exit do
        end if
    loop
    Rtrim$=String$
end function

function InsideBrackets(xx$,Z) 'inside brackets
Err$="F InsideBrackets(xx$,Z)" 'Move past double quotes in xx$
IF OFFSUB=0 THEN
    Ln=Ln+4: call logit Err$ 
    print tab(Ln); Err$: Ln=Ln-4: OFFSUB=1
END IF
    InsideBrackets=0
    IF  Z = 0 THEN EXIT FUNCTION
    Y = 0 :  X = 0
    DO
        Y = INSTR(xx$,"(", X+1): if Y=0 then exit function
        X = INSTR(xx$,")", Y+1): if X=0 then exit function
    loop until (Z>Y and Z<X)
    InsideBrackets=Y
END function

'_______________________________________________
function Search.For.Ref$(Ref$,LastRecord)
Err$="Search_For_Ref("+Ref$+")"
IF OFFSUB=0 THEN
    Ln=Ln+4: call logit Err$ 
    print tab(Ln); Err$: Ln=Ln-4: OFFSUB=1
END IF

    Namey$=Ref$
    Namey=val(Ref$)

    TopRecord = 1
    BottomRecord = LastRecord
    do
        MidPoint = INT((TopRecord + BottomRecord) / 2)
        test = val(LEFT$(Record$(MidPoint),LEN(Namey$)))
        IF test = Namey THEN EXIT DO '---------------->
        IF Namey>test THEN
            TopRecord = MidPoint + 1
        ELSE
            BottomRecord = MidPoint - 1
        END IF
    LOOP UNTIL (TopRecord > BottomRecord)
      ' ______________________________________________________________________
      '/Found Record Set to value$ without Ref number                         \
        IF test = Namey THEN
            Search.For.Ref$=mid$(Record$(MidPoint),LEN(Namey$)+3)
        else
            Search.For.Ref$ ="No_Quote_Found"
        end if
      '\______________________________________________________________________/

END function

'______________________________________________
sub Return.Code.Quotes Scaned$,Fixed$,FileIn$
Err$="Return.Code.Quotes Scaned$,Fixed$,FileIn$"
IF OFFSUB=0 THEN
    Ln=Ln+4: call logit Err$ 
    print tab(Ln); Err$: Ln=Ln-4: OFFSUB=1
END IF

    ' _________________________________________________________
    '/ Load Record$() with Quote Records                       \
    open CONVERT$+FileIn$ for input as #f14
        N=0: do until eof(#f14): line input #f14,T$: N=N+1: loop
    close #f14

    Redim  Record$(N+1)
    open CONVERT$+FileIn$ for input as #f15
        N=0
        do until eof(#f15)
            line input #f15,T$: N=N+1
            Record$(N)=T$
        loop
    close #f15
    '\_________________________________________________________/

    LastRecord=N
   ' ________________________________________________________
   '/Search for Quote = ref points                           \
    open CONVERT$+Fixed$ for output as #f11
    open CONVERT$+Scaned$ for Input as #f10
   '\________________________________________________________/
        EmptyLines=0: FoundPlace=0 'Place limit of ref number
        do until eof(#f10)
            line input #f10,xx$
            Q=1 'set so loop works
            do until Q=0
                Q=instr(xx$,"quote$(",Q)
                if Q>0 then
                    S=Q+7 'start of ref #
                    R=instr(xx$,")",S)'end of number
                    P=R+1: R=R-1  'P right side of line, R end of number
                    RF=val(mid$(xx$,S,R-S+1)) 'ref value
                    Y1$=Left$(xx$,Q-1) 'left side of line
                    Y3$=mid$(xx$,P)    'right side of line
                    Namey$="0000000"+str$(RF)
                    Namey$=right$(Namey$,Place) 'place is length of Ref
                    Y2$=Search.For.Ref$(Namey$,LastRecord)
                    Q=S 'move search point just in case Y2$=""
                    if len(Y2$)>0 then
                        Y2$=chr$(34)+Y2$+chr$(34)
                        xx$=Y1$+Y2$
                        Q=len(xx$)
                        xx$=xx$+Y3$
                        QuotePlace=QuotePlace+1
                    else
                        EmptyQuotes=EmptyQuotes+1
                    end if
                end if
            loop
            print #f11,xx$
        loop
    ' _________________
    '/Close OPEN Files \
     close #f10
     close #f11
    '\_________________/
     if RemarkMissed>0 then print "Remarks Missed=";RemarkMissed
     Ln=Ln+4
     call logit "Quotes Missed=";EmptyQuotes
     call logit "Quotes Found=";QuotePlace
     Ln=Ln-8

end sub
'______________________________________________
sub Return.Code.Remarks Scaned$,Fixed$,FileIn$
Err$="Return.Code.Remarks Scaned$,Fixed$,FileIn$"
IF OFFSUB=0 THEN
    Ln=Ln+4: call logit Err$ 
    print tab(Ln); Err$: Ln=Ln-4: OFFSUB=1
END IF
    ' _________________________________________________________
    '/ How many records in Remark file                         \
    open CONVERT$+FileIn$ for input as #f14
        N=0: do until eof(#f14): line input #f14,T$: N=N+1: loop
    close #f14
    ' __________________________________________
    '/empty and size array for Search of Remarks\
            Redim  Record$(N+1)
    '\__________LOAD Record$()__________________/
    open CONVERT$+FileIn$ for input as #f15
        N=0
        do until eof(#f15)
            line input #f15,T$: N=N+1
            Record$(N)=T$
        loop
    close #f15
    '\_________________________________________________________/

    LastRecord=N 'number of records in array to be searched
   ' ________________________________________________________
   '/Search for Quote = ref points                           \
    open CONVERT$+Fixed$ for output as #f11
    open CONVERT$+Scaned$ for Input as #f10
   '\________________________________________________________/
        RemarkMissed=0: RemarkFound=0 'Holds record of search
       ' ________________________________________________________
       '/Return Remarks to BAS Code                              \
        do until eof(#f10)
            line input #f10,xx$
            Q=instr(xx$,": REMARK="): if Q=0 then Q=instr(xx$," REMARK=")
            '____________________________________________________________
            if Q>0 then
                do until Q=0 'error exit loop
            '___________Remark_Record_Found______________________________
                    S=Q: Q=0 'start of remark ref
                    R=instr(xx$,"=",S)+1 'start of ref number
                    if R=0 then exit do '---------------->
                    E=R+Place 'end of ref#
                    '__GET_REF_NUMBER_____________
                    Namey$=TRIM$(mid$(xx$,R,Place))
                    Y1$=Left$(xx$,S-1) 'left side of line
                    Y3$=mid$(xx$,S)    'eliminated right side of line
                    Y2$=Search.For.Ref$(Namey$,LastRecord)
                    if len(Y2$)>0 then
                        xx$=Y1$+Y2$
                        RemarkFound=RemarkFound+1
                    else
                        RemarkMissed=RemarkMissed+1
                    end if
                 loop
            end if
            '____________________________________________________________

            print #f11,xx$
        loop
       '\_As_Action_Code_ends_with_Remark_so_does_search_of_line_/
    ' _________________
    '/Close OPEN Files \
     close #f10
     close #f11
    '\_________________/
     if RemarkMissed>0 then print "Remarks Missed=";RemarkMissed
     Ln=Ln+4
     call logit "Remarks Missed=";RemarkMissed
     call logit "Remarks Found=";RemarkFound
     Ln=Ln-8

end sub

function Isolate.Statement$ (byref Y1$, byref Y3$, xx$, Z)
Err$="Isolate.Statement$ byref Y1$, byref Y3$, xx$, Z"
IF OFFSUB=0 THEN
    Ln=Ln+4: call logit Err$ 
    print tab(Ln); Err$: Ln=Ln-4: OFFSUB=1
END IF
'TESTED with junk and works
'Isolates colin statements to the right and left of Z statement
'Z>len(xx$) will grab last statement, Z=0 will grab first statement
'Len(xx$)=0 will return xx$=Y1$ and Y3$
'sets Y1$= to left statements, Y3$= to right statements
'adds to Y1$, Y3$; may change value for Y1$,Y3$ to " '"
'XX$ will have spaces on each side so it can be searched properly
'==============================================================
'_________________________________________
    if Z=0 then Z=1 'search starts at string position 1
    xx$=trim$(xx$)
    '________________________________________
    '/isolate Right of Z statement\
    Z2=instr(xx$," : ",Z) 'Is there statement after Z
    '______________________________________________________
    if Z2>0 then '/right colin side of line found\
    '--------------------------------------------------------
        Y$=trim$(mid$(xx$,Z2)): Y3$=trim$(Y3$) ' ?? : xx$ Z:2 Y3$ '
        if right$(Y$,1)="'" then Y$=trim$(left$(Y$,len(Y$)-1))
        if len(trim$(Y3$))=0 then Y3$="'"
        Y3$=Y$+space$(1)+Y3$ '?? : xx$ [: Y3$ ']
        xx$=trim$(left$(xx$,Z2))' ?? : xx$ 
    else
        if len(trim$(Y3$))=0 then Y3$=" '" 'create right side space
    '--------------------------------------------------------
    end if
    '_______________________________________________
    Z2=0:Lc=0'/isolate Left of Z statements\
    if left$(xx$,1)="'" then xx$=trim$(mid$(xx$,2))
    '_________________________________________________
    do '/move from left to right looking for colin\
    '----------------------------------------------------------------
        Z2=instr(xx$," : ",Z2+1): if (Z2<Z and Z2>Lc) then Lc=Z2+2 'last colin before Z
    '----------------------------------------------------------------
    loop until Z2=0
    '______________________________________________________
    if Lc>0 then '/Isolate left colin statement\
    '------------------------------------------------------

        Y1$=trim$(Y1$): if len(Y1$)=0 then Y1$="'"

        Y1$=Y1$+space$(1)+trim$(Left$(xx$,Lc)) 'left side to colin
        xx$=trim$(mid$(xx$,Lc)) 'right side of colin
    '-----------------------------------------------
    else
    '----------------------------------------------
        if Len(trim$(Y1$))=0 then Y1$="' " 'no left side statements
    '-----------------------------------------------
    end if
    [output.total.line]
    '______________________________________________________________
    if len(trim$(xx$))=0 then '/combine right and left statements\
        Z$=trim$(Y1$)+" : "+trim$(Y3$): Y3$="": Y1$=""
        do
            Z=instr(Z$,": :")
            if Z>1 then
                Z=Z+1
                A$=left$(Z$,Z)
                Z=Z+2
                B$=mid$(Z$,Z)
                Z$=A$+B$ 
            end if
            T=instr(Z$,"  ")
            if T>1 then
                A$=trim$(left$(Z$,T)) 'captures space
                T=T+1
                B$=trim$(mid$(Z$,T))
                Z$=A$+space$(1)+B$
                Z=T
            end if

        loop until Z=0
        do
            X$=left$(Z$,1)
            if X$="'" or X$=":" then
                Z$=trim$(mid$(Z$,2))
            else
                X$=right$(Z$,1)
                if X$="'" or X$=":" then
                    Z$=trim$(left$(Z$,Len(Z$)-1))
                else
                    X$=""
                end if
            end if
        loop until X$=""
        xx$="' "+Z$+" '"
    else
        do
            Z=(left$(xx$,1)=":" or left$(xx$,1)="'"): if Z>0 then xx$=trim$(mid$(xx$,2))
            if Z=0 then Z=(right$(xx$,1)=":" or right$(xx$,1)="'"): if Z>0 then xx$=trim$(left$(xx$,len(xx$)-1))
        loop until Z=0
        xx$=space$(1)+xx$+space$(1)
    end if
    Isolate.Statement$=xx$
end function













































































































































































































































































































































































































































































