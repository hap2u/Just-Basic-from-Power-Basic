[code.Descriptive.Outline]
mainwin 120 40

' PB Syntax JB Fix: INSTR(string1, string2[, starting])
'you can not have two labels together without an operation
'undo last does not return last line entry
'02040608101214161820222426283032343638404244464850525456586062646668707274767880
' Note: Front is Western Courier New regular 10
'       Using Under Score _ try to keep CODE Lines under 80. This allows other
'       reference window; [AA_Convert_PB-JB.log.TXT]; to be used while Coding.
'  ___________________________________________________________________________
' /                                                                           \
'| PB to JB TRANSLATION_AID.BAS                                                |
'| 1. Hugh Polley   2020/02/04                                                 |
'|                                                                             |
'| This code is to be considered "public domain".' Feel free to do what you    |
'| want with it. If you come with an improvement please post it here so all    |
'| Basic users get the benefit.                                                |
'| If you make changes to the CODE add your name and date to above listing!    |
'|                                                                             |
'| Disclaimer:                                                                 |
'| This code is provided as-is and it does not have any warranty of any kind.  |
'| User is responsible for any misuse of the code. Do not use this code in     |
'| whole or in part if you can not accept these terms!                         |
' \___________________________________________________________________________/
'
'  ___________________________________________________________________________
' /                                                                           \
'|Purpose: Translation Code Outline for Power Basic BAS files to Just Basic    |
'|    or: Translation Code Outline for Power Basic BAS files to Python Basic   |
' \___________________________________________________________________________/
'
'  ___________________________________________________________________________
' /                                                                           \
'|       MY PAST TRANSLATE PROGRAMS HAD ONE OR MORE OF THESE METHODS           |
'| NOTE: To Accomplish (1-12) run program again as required after each Step    |
'|01. Get [InFile$=PB_file.bas] from [Load last translation.txt]               |
'|02. Sub Directory [!CONVERT] must already exist                              |
'|03. Program will Place a copy of the pre translated PB code into [!CONVERT]  |
'|04. Program will create an Execution LOG File in CONVERT [BB_PB->JB.log.TXT  |
'|05. Program Creates [BB.Scaned-Code.txt] for last update to converted File!  |
'|    NOTE: control what is executed by deleting records from bottom to top!   |
'|06. Change any double spaces to single staces to aid phrase searches         |
'|07. To Aid in searching through Code, keep REM quote + [Space] at the        |
'|    start of each line and a [Space] + REM Quote at end of each line         |
'|08. For each Syntax Change Have Scaned$ = Fixed$, Fixed$=new fix             |
'|    [OPEN Fixed$ FOR OUTPUT] and [OPEN Scaned$ FOR INPUT]                    |
'|09. Highlight lines which need Manual Fix with [< line >]                    |
'|10. For PYTHON Highlight GOTO and Line they branch to with the same Number   |
'|     <## ?? ?> Most can be fixed with DO-LOOP, CASE, IF-THEN-ELSE and/or     |
'|    SUB/FUNCTION routines.                                                   |
'|=============================================================================|
'|Note:                                                                        |
'|exp. Change required GOTO,GOSUB [###], statements that have a value greater  |
'|    than zero! exp. VAL("100") > 0 so change to VAL("z100") = 0  GOSUB 100   |
'|    becomes GOSUB z100                                                       |
' \___________________________________________________________________________/
'

on error goto [ErrorHandler]
[GLOBAL.1]
GLOBAL InFile$,CONTROL$,CONVERT$,Fixed$,Scaned$,Skip,Problem,Problem$
GLOBAL Structure, Syntax, Found, Place, Ln, OFFSUB, SUB1OFF, SUB2OFF
GLOBAL f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,f14 'open file values
'_____________SET_FILE_NUMBERS________________________________________
f1=1: f2=2: f3=3: f4=4: f5=5: f6=6: f7=7: f8=8: f9=9: f10=10
f11=11: f12=12: f13=13: f14=14
Place=5: Ln=0 'Size of Reference Numbers!
Skip=0: Found=0 'recording how many procedures
OFFSUB=0: SUB1OFF=0: SUB2OFF=0: Problem=0: dim Problem$(20)
'______________________________________________________________________________|
[OUTPUTsettingsFORfilesANDlines] Skip=0
Err$="SET [OUTPUTsettingsFORfilesANDlines]<"+str$(Skip)+">"
Err0$=Err$
    CONTROL$="!CONTROL\"
    CONVERT$="!CONVERT\"
    print: print tab(Ln);Err$
'______________________________________________________________________________|
[DOESsubdiectory!CONTROLexist] Skip=Skip+1
Err$="SET [DOESsubdiectory!CONTROLexist]<"+str$(Skip)+">"
Err1$=Err$
print tab(Ln);Err$
    result = mkdir( "!CONTROL")
    if result <> 0 then
        print "|_____________________________________|"
        print "| [!CONTROL] directory EXISTS !       |"
        print "| Working Directory for .temp Files!  |"
        print "|-------------------------------------|"
    else
        print "|_____________________________________|"
        print "| [!CONTROL] directory CREATED!       |"
        print "| Working Directory for temp Results! |"
        print "|-------------------------------------|"
        print
        Err$= " {{RUN JB Program Again! }}"
        goto [ErrorHandler]
    end if

'______________________________________________________________________________|
[DOESsubdirectory!CONVERTexist] Skip=Skip+1
Err$="SET [DOESsubdirectory!CONVERTexist]<"+str$(Skip)+">"
Err2$=Err$
print tab(Ln);Err$
    result = mkdir( "!CONVERT")
    if result <> 0 then
        print "|_________________________________________________|"
        print "| [!CONVERT] directory EXISTS!                    |"
        print "| Working Directory for Translation Files !       |"
        print "|-------------------------------------------------|"
        print
    else
        print "|_________________________________________________|"
        print "| [!CONVERT] directory CREATED!                   |"
        print "| Working Directory for Translation Files !       |"
        print "|-------------------------------------------------|"
        print
        Err$="<ERROR> <This is B.PREP>  <RUN A.PREP FIRST!> <ERROR>"
        Found=Skip-1 'goes to end of program
        goto [ErrorHandler]
    end if
'______________________________________________________________
[Get.From.Translation.txt.BAS.file.TO.be.CONVERTED] Skip=Skip+1
Err$="SET [Get.From.Translation.txt.BAS.file.TO.be.CONVERTED]<"+Str$(Skip)+">"
Err3$=Err$ 
print tab(Ln);Err$ 
    ' ____________________________________________________________
    '/Translated Just Basic Code Files                            \
    open "Load Last Translation.TXT" for append as #f1: close #f1
    open "Load Last Translation.TXT" for input as #f2
    '\____________________________________________________________/
        Found=0'number of files found used to avoid translating more than needed
        InFile$="" 'will hold last record in file for procedure Found>skip?
        '____________________________________________________________
        do until eof(#f2)
            input #f2,X$
            IF instr(UPPER$(X$),".BAS")>4 THEN InFile$=X$: Found=Found+1
        loop
     ' ___________________________________________________________
     '/ Last file in Text File with extension of .BAS is used     \
     close #f2
     '\___________________________________________________________/
    if Found<>2 then 'corrupt or empty file
        '________________________________________________________
            cls: print
            Err$="<ERROR>Corrupt [Load Last Translation.TXT] File!<ERROR>"
            print Err$
            print "Files Found=(";Found;") <> 2"
            print "<Last file found: ";X$;">"
            print tab(Ln+4);
            Err$="<There should be two files second one [BB.Name.BAS] File>"
            print Err$
            goto [ErrorHandler]
    else
        [try1START] on error goto [try1CATCH1]
            open CONVERT$+InFile$ for input as #f3: close #f3
            goto [try1END] 'file exists!
        [try1CATCH1] on error goto [try1CATCH2]
            open InFile$ for input as #f4
            open CONVERT$+InFile$ for output as #f5
                do until eof(#f4)
                    line input #f4,Record$
                    print #f5, Record$
                loop
            close #f4
            close #f5
            Err=0: on error  goto [ErrorHandler]
            Err$="SET File: ["+InFile$+"] Loaded into Folder CONVERT!"
            print Err$
            Err$=" { File Error Corrected { RUN JB Program Again! }}"
            goto [ErrorHandler]
        [try1CATCH2] on error goto [ErrorHandler]
            print "< Corrupt [LOAD LAST TRANSLATION.TXT] AS >"
            Err$="<ERROR> [BB.PB File] Not Found in Root Folder! <ERROR>"
            goto [ErrorHandler]
        [try1END] on error goto [ErrorHandler] '!CONVERT Power Basic Program exist
    end if

'______________________________________________________________________________|
[CLEARandCREATElogfile]  Skip=Skip+1
Err$="SET [CLEARandCREATElogfile]<"+str$(Skip)+">"
print tab(Ln);Err$
    ' ___________________________________________________
    '/Create procedure Log File                          \
    open CONVERT$+"BB.PB to JB.log.TXT" for output as #f1
    '\___________________________________________________/
        PRINT #f1,"<"+InFile$+">"
        print #f1, Err0$
        print #f1, Err1$
        print #f1, Err2$
        print #f1, Err3$
        print #f1, Err$
    close #f1
    '\___________________________________________________/

'______________________________________________________________________________|
[in!CONVERTfindLAST.bas] Skip=Skip+1
Err$="SET [in!CONVERTfindLAST.bas]<"+str$(Skip)+">"
call logit Err$
print tab(Ln);Err$
    dim info$(1,1) 'dim needed for info to gather file information
    files DefaultDir$+"\!CONVERT", "BB.*.BAS", info$() 'checks for BAS files
    Number=val(info$(0,0))
    '___________________________________________________________
    if Number<>1 then '/Right BAS file not found in Folder?     \
        if Number>1 then Err$="<More than expected [BB.?File?.BAS] In Folder!>"
        if Number<1 then Err$="<BAS File [BB.?File?.BAS] not found!>"
        call logit Err$
        print space$(Ln)+Err$
        print "|_________________________________________________|"
        print "|   Program BUG or OPERATOR ERROR In              |"
        print "|   [!CONVERT] directory                          |"
        print "|-------------------------------------------------|"
        print "| <Where is BB. [";InFile$;"]>"
        print "|_________________________________________________|"
        print
        Err$="<Check to see what happened to [BB.File.BAS]>"
        goto [ErrorHandler]
    end if

'______________________________________________________________________________|
[CHECKforLASTcompletedCODEscan] Skip=Skip+1
Err$="SET [CHECKforLASTcompletedCODEscan]<"+str$(Skip)+">"
call logit Err$
print tab(Ln);Err$
    ' ____________________________________________________________
    '/Translated Just Basic Code Files                            \
    open CONVERT$+"BB.Scaned.Code.txt" for append as #f2: close #f2
    open CONVERT$+"BB.Scaned.Code.txt" for input as #f2
    '\____________________________________________________________/
        Found=0'number of files found used to avoid translating more than needed
        Fixed$="" 'will hold last record in file for procedure Found>skip?
        '____________________________________________________________
        do until eof(#f2)
            input #f2,X$ 
            if len(trim$(X$))>0 then Fixed$=X$: Found=Found+1
        loop
        '-----------------------------------------------------------
     close #f2
     '\___________________________________________________________/

    if len(trim$(Fixed$))=0 then
        open CONVERT$+"BB.Scaned.Code.txt" for output as #f2
            print #f2,InFile$ 
        close #f2
        Err$="<PLACED [";InFile$;"] into [BB.Scaned.Code.txt]!>"
        print tab(Ln+4);Err$
        Err$="{{ RUN JB Program Again! }}"
        goto [ErrorHandler]
    else
        print tab(Ln);"SET "+Fixed$+": <# Files Found=";Found;">"
    end if

' _____________________________________________________________________________
'/From this point on Fixed$ is used for File output; Scaned$ is used for File  \
'|input, eg. Scaned$=Fixed$, Fixed$=InFile$+##+des.basJ                         |
'|At this point in Code Skip is = 0, Skip/Found controls where you are at in    |
'|Translation Process! Mess with above Code at your own Risk!     |             |
  Skip=0: print "< -- > Decreasing number for each adjustment < -- >": Ln=Ln+4
'\_____________________________________________________________________________/

'________________________________________________
[Find.AS.string.GLOBAL.and.DIM] Skip=Skip+1
Err$="M [Find.AS.string.GLOBAL.and.DIM]<"+str$(Found-Skip)+">"
call logit Err$
print tab(Ln);Err$
If Found>Skip then GOTO [Reconstruct.to.Bracket]
    ' _________________________________________
    '/SETUP Variables                          \
        OFFSUB=0
        Scaned$=Fixed$
        Fixed$=InFile$+".01.AsString.basJ"
    '\_________________________________________/

    ' __________________________________________________________________
    '/open Random file to handle operations without reloading and saving\
    open CONTROL$+Fixed$ for random as #f10 len = 300  'RecordSize
    field #f10, 300 as BasRecord$
        ' ______________________________________________________________
        '/LOAD PB CODE LINES INTO RANDOM ARRAY and get number of records\
        open CONVERT$+Scaned$ for INPUT as #f11: RecordNumber=0
        do until eof(#f11)
            RecordNumber=RecordNumber+1
            line input #f11, BasRecord$: BasRecord$=trim$(lower$(BasRecord$))
            if  left$(BasRecord$,1)<>"'" then BasRecord$="' "+BasRecord$
            if right$(BasRecord$,1)<>"'" then BasRecord$=BasRecord$+" '"
            '==============================================================
            for Rp=1 to 2
                if Rp=1 then Find$=" as string "
                if Rp=2 then Find$=" as long "
                Y1$="": Y3$="": ZZ=1
                '_____________________________________________________________
                do until ZZ=0 '/work loop for multi statements on one line   \
                    ZZ=instr(BasRecord$,Find$,ZZ)'what you are looking for
                    if ZZ>0 then 'found Find$ on line
                        Z1=ZZ: ZZ=ZZ+len(Find$) 'move to next spot on line
                        '________________________________________________________________
                        '/isolate statement part of line                         \
                        zz$=Isolate.Statement$ (Y1$, Y3$, BasRecord$, Z1)
                        '-------------------------------------
                        F$=" global ": Z=instr(zz$,F$)
                        '___________________________________________
                        if Z=1 then '/test for comma global line\
                            q1$="": q2$="": F$=" , ": Z=instr(zz$,F$)
                            if Z>0 then
                                q1$=trim$(left$(zz$,Z))
                                q2$=trim$(mid$(zz$,Z+2))
                                zz$=q1$+" : global "+q2$+space$(1)
                                ZZ=len(Y1$+zz$)
                                Y3$=zz$+trim$(Y3$): zz$=""
                                Z=0: BasRecord$=Isolate.Statement$ (Y1$, Y3$, zz$, Z)
                            end if
                        end if
                    end if
                loop
            next Rp
            '==========================================================
            put #f10,RecordNumber
        loop
        close #f11
        '\______________________________________________________________/
        'RANDOM FILE #F10 IS OPEN
        ' ________________________________________________________________
        '/Find Dim and Redim String STATEMENTS remove AS STRING and repair\
        Find1$=" as ": Find2$="global ": Find3$="string "
        Find$=Find1$+Find2$+Find3$: Find2$=Find1$+Find2$
        '______________________________________
        OFFSUB=0: gosub [Rsub.Repair.and.Remove.AS.STRING]
        '--------------------------------------
        Find$=Find1$+Find3$: Find2$=""
        '_______________________________________
        OFFSUB=0: gosub [Rsub.Repair.and.Remove.AS.STRING]
        '---------------------------------------
        Find1$=" as ": Find2$="global ": Find3$="long "
        Find$=Find1$+Find2$+Find3$: Find2$=Find1$+Find2$
       '______________________________________
        OFFSUB=0: gosub [Rsub.Repair.and.Remove.AS.long]
        '--------------------------------------
        Find$=Find1$+Find3$: Find2$=""
        '_______________________________________
        OFFSUB=0: gosub [Rsub.Repair.and.Remove.AS.long]
        '---------------------------------------

    'RANDOM FILE #F10 IS OPEN
    ' __________________________________________________
    '/Output Repaired Random file to CONVERT$ Folder    \
    open CONVERT$+Fixed$ for output as #f12
        For R=1 to RecordNumber
            get #f10,R : BasRecord$=trim$(lower$(BasRecord$))

            if Left$(BasRecord$,1)<>"'" then BasRecord$="' "+BasRecord$
            if Right$(BasRecord$,1)<>"'" then BasRecord$=BasRecord$+" '"
            print #f12,BasRecord$
       next R
    close #f12: close #f10
    '\__________________________________________________/

' _________________________________________________
'/ SAVE LAST OUTPUT FILE TO CONTROLING TEXT FILE   \
   call Record.Repaired.Code
'\_________________________________________________/
Err$="{{ RUN JB Program Again! }}"
goto [ErrorHandler]
'_________________________________________________________________________
[Rsub.Repair.and.Remove.AS.STRING] Ln=Ln+4
Err$="[Sub.Repair.and.Remove.AS.STRING]<"+Find$+">"
call logit Err$
print tab(Ln);Err$ 
' __________________________________________________________________
'/Find Global AS String or AS String and fix with $                 \
for N=1 to RecordNumber
    get #f10,N : BasRecord$=trim$(lower$(BasRecord$))'fix up found random statement
    AraySize$="":ArrayName$="": zz$=BasRecord$
    Y1$="": Y3$="": ZZ=1
    '_____________________________________________________________
    do until ZZ=0 '/work loop for multi statements on one line   \
        ZZ=instr(BasRecord$,Find$)'what you are looking for
        if ZZ>0 then 'found Find$ on line
        '________________________________________________________________
           '/isolate statement part of line                         \
            BasRecord$=Isolate.Statement$ (Y1$, Y3$, BasRecord$, ZZ)
            '-------------------------------------
                F$=" dim ": Z=instr(BasRecord$,F$)
                if Z=0 then F$=" redim ": Z=instr(BasRecord$,F$)
                if Z=0 then F$=" function ": Z=instr(BasRecord$,F$)
                if Z=0 then
                    if instr(Find$,"global")=0 then
                        F$=" global ": Z=instr(BasRecord$,F$)
                        if Z<>1 then Z=0
                    end if
                end if
                if Z=0 then
                    BasRecord$="<ERROR>no defining statement<ERROR><"+zz$+">"
                    put #f10,N
                    Problem=Problem+1
                    Problem$(Problem)=BasRecord$
                    call logit Problem$(Problem)
                    exit do
                end if

                S1=Z+len(F$) 'move to start of name
                '------------------------------------
                Z0=0
                Z=instr(BasRecord$," ( ",S1): if Z=0 then Z0=instr(BasRecord$,space$(1),S1)
                if Z0>0 then Z=Z0
                if Z=0 then
                    Problem=Problem+1
                    Problem$(Problem)="<ERROR>no space after name?><"+zz$+">"
                    BasRecord$=Problem$(Problem)
                    call logit Problem$(Problem)
                    put #f10,N
                    exit do
                end if
                S2=Z
                ArrayName$=trim$(Mid$(BasRecord$,S1,S2-S1+1))
                '-----------------------------------
                Z1=S2+1
                if Z0=0 then
                    Z2=instr(BasRecord$," ) ",Z1)+1
                    AraySize$=space$(1)+trim$(mid$(BasRecord$,Z1,Z2-Z1+1))+space$(1)
                    if len(trim$(AraySize$))=0 then AraySize$=space$(1)
                else
                    AraySize$=space$(1)
                end if
                '-----------------------------------
                Y2$=F$+ArrayName$+AraySize$+Find2$
                BasRecord$=trim$(Y1$)+space$(1)+trim$(Y2$)+space$(1)+Trim$(Y3$)
                ZZ=1
                '----------------------------------
                put #f10,N
                ArrayName$=space$(1)+ArrayName$+space$(1)
                ' _______________________________________
                '/add $ to AS STRING Variable or Function\
                For A=1 to RecordNumber
                    get #f10,A : BasRecord$=trim$(lower$(BasRecord$))
                    Z1=instr(BasRecord$,ArrayName$)
                    if Z1>0 then
                        X$=trim$(left$(BasRecord$,Z1+len(ArrayName$)-1))
                        Y$=trim$(mid$(BasRecord$,Z1+len(ArrayName$)))
                        BasRecord$=X$+"$ "+Y$
                        if A=N then Y2$=BasRecord$
                        put #f10,A
                    end if
                next A
                BasRecord$=Y2$
                Y1$="":Y3$=""
            end if
        loop

    Next N

'=================================================================
Ln=Ln-4: return
'_________________________________________________________________________
[Rsub.Repair.and.Remove.AS.long] Ln=Ln+4
Err$="[Rsub.Repair.and.Remove.AS.long]<"+Find$+">"
call logit Err$
print tab(Ln);Err$ 
' __________________________________________________________________
'/Find Global AS String or AS String and fix with $                 \
for N=1 to RecordNumber
    get #f10,N : BasRecord$=trim$(lower$(BasRecord$))'fix up found random statement
    AraySize$="":ArrayName$="": zz$=BasRecord$
    Y1$="": Y3$="": ZZ=1
    '_____________________________________________________________
    do until ZZ=0 '/work loop for multi statements on one line   \
        ZZ=instr(BasRecord$,Find$)'what you are looking for
        if ZZ>0 then 'found Find$ on line
        '________________________________________________________________
           '/isolate statement part of line                         \
            BasRecord$=Isolate.Statement$ (Y1$, Y3$, BasRecord$, ZZ)
            '-------------------------------------
                F$=" dim ": Z=instr(BasRecord$,F$)
                if Z=0 then F$=" redim ": Z=instr(BasRecord$,F$)
                if Z=0 then F$=" function ": Z=instr(BasRecord$,F$)
                if Z=0 then
                    if instr(Find$,"global")=0 then
                        F$=" global ": Z=instr(BasRecord$,F$)
                        if Z<>1 then Z=0
                    end if
                end if


                if Z=0 then
                    BasRecord$="<ERROR>no defining statement<ERROR><"+zz$+">"
                    put #f10,N
                    Problem=Problem+1
                    Problem$(Problem)=BasRecord$
                    call logit Problem$(Problem)
                    exit do
                end if

                S1=Z+len(F$) 'move to start of name
                '------------------------------------
                Z0=0
                Z=instr(BasRecord$," ( ",S1): if Z=0 then Z0=instr(BasRecord$,space$(1),S1)
                if Z0>0 then Z=Z0
                if Z=0 then
                    Problem=Problem+1
                    Problem$(Problem)="<ERROR>no space after name?><"+zz$+">"
                    BasRecord$=Problem$(Problem)
                    call logit Problem$(Problem)
                    put #f10,N
                    exit do
                end if
                S2=Z
                ArrayName$=trim$(Mid$(BasRecord$,S1,S2-S1+1))
                '------------------------------------
                Z1=S2+1
                if Z0=0 then
                    Z2=instr(BasRecord$," ) ",Z1)+1
                    AraySize$=space$(1)+trim$(mid$(BasRecord$,Z1,Z2-Z1+1))+space$(1)
                    if len(trim$(AraySize$))=0 then AraySize$=space$(1)
                else
                    AraySize$=space$(1)
                end if
                '--------------------------------------
                Y2$=F$+ArrayName$+AraySize$+Find2$
                ZZ=1: BasRecord$=trim$(Y1$)+space$(1)+trim$(Y2$)+space$(1)+Trim$(Y3$)
                '----------------------------------
                Y1$="":Y3$=""
            end if
        loop
        put #f10,N
    Next N
'=================================================================
Ln=Ln-4: return
'_______________________________________
'__________________________________________________
[Reconstruct.to.Bracket] Skip=Skip+1
Err$="M [Reconstruct.to.Bracket]<"+str$(Found-Skip)+">"
call logit Err$
print tab(Ln);Err$
If Found>Skip then GOTO [Take.and.repair.GLOBAL]
    ' _________________________________________
    '/SETUP Variables                          \
        OFFSUB=0
        Scaned$=Fixed$
        Fixed$=InFile$+".02.TObracket.basJ"
    '\_________________________________________/

    ' ______________________________________________________
    '/OPEN Files for input and Output                       \
    open CONVERT$+Fixed$ for OUTPUT as #f6
    open CONVERT$+Scaned$ for INPUT as #f5
    '\______________________________________________________/
    do until EOF(#f5)
    '----------------------------------------------------------
        Y1$="": Y3$="": T=0
        line input #f5, xx$: xx$=trim$(xx$)
        '/Is there quote space?\
        if left$(xx$,1)<>"'" then xx$="' "+trim$(mid$(xx$,2))
        if right$(xx$,1)<>"'" then xx$=trim$(left$(xx$,len(xx$)-1))+" '"
        zz$=xx$ 'for problem$ output
        '_______________________________________________________
        do :Z=0: Z1=0'/work do for multible statement line\
            '____________________________________
            '/Is there a 'TO' inside brackets?  \
            do
                Z=instr(xx$," to ",Z+1)
                if Z>0 then Z1=InsideBrackets(xx$,Z): if Z1>0 then exit do
            loop until Z=0
            '________________________________________________
            if Z>0 then '/TO' found get statement\
                Y1$="": Y3$="": Z2=Z 'store statements
                '/isolate Right of 'TO' statements\
                Z2=instr(xx$," : ",Z2+1) 'Is there statement after to
                if Z2>0 then 'right side of statement found
                '--------------------------------------------------------
                    Y3$=trim$(mid$(xx$,Z2+1)) 'colin divided right side
                    xx$=left$(xx$,Z2)'left remainder with valid Z1 location
                else
                    if len(Y3$)=0 then Y3$=" '" 'no right side statements
                    '--------------------------------------------------------
                end if
                '_______________________________________________
                '/isolate Left of 'TO' statements\
                Z2=0:Lc=0
                do 'move right along line seperate left statements
                '----------------------------------------------------------------
                    Z2=instr(xx$," : ",Z2+1): if (Z2<Z and Z2>Lc) then Lc=Z2 'colin location
                '----------------------------------------------------------------
                loop until Z2=0
                if Lc>0 then 'Isolate left colin statement
                '------------------------------------------------------
                    Y1$=trim$(Left$(xx$,Lc+1)) 'left side to colin
                    xx$=trim$(mid$(xx$,Lc+2)) 'right side from colin
                '-----------------------------------------------
                else
                '----------------------------------------------
                    if Len(Y1$)=0 then Y1$="' " 'no left side statements
                '-----------------------------------------------
                end if
                if left$(xx$,1)="'" then xx$=trim$(mid$(xx$,2))
                if right$(xx$,1)="'" then xx$=trim$(left$(xx$,len(xx$)-1))
                xx$=space$(1)+xx$+space$(1)
                '_____________________________________________________
                '  /move along XX$ to bracket, then to, extract first
                Z1=instr(xx$," ( ")+1
                '______________________________________________________
                Z3=instr(xx$,"$ , ")'/String operation ?\
                if Z3>0 then Z3=Z3+3: Z1=Z3
                Z1$=left$(xx$,Z1) 'take out xx$ --> (
                xx$=mid$(xx$,Z1+1) 'xx$ after first bracket
                Z1=instr(xx$," to ")
                X1$=trim$(left$(xx$,Z1))
                xx$=mid$(xx$,Z1+3)
                Z2=instr(xx$," ) ")
                X2$=trim$(left$(xx$,Z2))
                xx$=mid$(xx$,Z2+1)
                if Z3>0 then 'string operation
                    X3$=X1$+" , "+X2$+" - "+X1$+" + 1"
                else 'not a string operation
                    X3$=X2$+"-"+X1$
                end if
                Y1$=trim$(Y1$)+space$(1)
                Y3$=space$(1)+trim$(Y3$)
                Y1$=Y1$+Z1$+space$(1)+X3$+space$(1)+trim$(xx$)
                xx$="": if Y3$<>" '" then xx$=Y3$: Y3$=""
                T=1
           end if
        loop until Z=0
        xx$=Y1$+xx$+Y3$
        print #f6,xx$
    '----------------------------------------------------------------
    loop
   ' _________________
   '/Close OPEN Files \
        close #f6
        close #f5
   '\________________/

' _________________________________________________
'/ SAVE LAST OUTPUT FILE TO CONTROLING TEXT FILE   \
   call Record.Repaired.Code
'\_________________________________________________/

'Record repair not working
Err$="{{ RUN JB Program Again! }}"
goto [ErrorHandler]

[Take.and.repair.GLOBAL] Skip=Skip+1
Err$="M [Take.and.repair.GLOBAL]<"+str$(Found-Skip)+">"
call logit Err$
print tab(Ln);Err$
If Found>Skip then GOTO [EXTRACT.and.STORE.type.COMMAND]
    ' __________________________________________________
    '/SETUP Variables                                   \
        OFFSUB=0
        Scaned$=Fixed$
        Fixed$=InFile$+".03.AsGlobal.basJ"
        Long$=CONVERT$+"WW-GLOBAL.Variable.Store.TXT"
    '\__________________________________________________/

    [working.here.end] print "[working.here.end]": end

    ' ______________________________________________________
    '/OPEN Files for input and Output                       \
        open Long$ for append as #f7
        print #f7,"'-------[Take.and.repair.GLOBAL]---------"
        open CONVERT$+Fixed$ for OUTPUT as #f6
        open CONVERT$+Scaned$ for INPUT as #f5
    '\______________________________________________________/
    '---------------------
    Remove$=" as global "
    '---------------------
    ' ________________
    '/                \
    do until EOF(#f5)
        line input #f5, xx$: xx$=lower$(trim$(xx$)): zz$=xx$
        Z=instr(xx$,Remove$)
        '________________________________________________
        if Z>0 then '/     ' TO ' found             \
            print 1,xx$
            xx$=Isolate.Statement$ (Y1$, Y3$, xx$, Z)
            print 2,xx$
            Find$=" dim ": Z=instr(xx$,Find$)
            if Z=0 then Find$=" redim ": Z=instr(xx$,Find$)
            if Z=0 then Find$=" function ": Z=instr(xx$,Find$)
            if Z>0 then 'isolate Variable
                Z=Z+3: Z1=instr(xx$,space$(1),Z) 'first space
                if Z1>0 then Z1=Z1+1: Z2=instr(xx$,space$(1),Z1) 'second space
                if Z2=0 then
                    Problem=Problem+1
                    Problem$(Problem)="<"+Remove$+">Variable Name no Space?{"+zz$+"}"
                    call logit Problem$(Problem)
                '_________________________________
                else '/ save and remove GLOBAL\
                    Nm$=trim$(mid$(xx$,Z1,Z2-Z1+1))
                    print 3,Nm$
                    if Find$<>" function " then print #f7,Nm$
                    '__________________
                    '/remove AS GLOBAL\
                    Z=instr(xx$,Remove$): xx$=trim$(left$(xx$,Z))

                end if
                '___________________________
                '   /reform and save line\
                xx$=Y1$+space$(1)+xx$+space$(1)+Y3$
                print 4,xx$

            end if
        end if
        print #f6,xx$
    loop
   '\________________/
   ' _________________
   '/Close OPEN Files \
        close #f5
        close #f6
        close #f7
   '\________________/
[aa.working.here1] print "[aa.working.here]": end
' __________________________________________________
'/ SAVE LAST OUTPUT FILE TO CONTROLING TEXT FILE    \
   call Record.Repaired.Code
'\__________________________________________________/
Err$="{{ RUN JB Program Again! }}"
goto [ErrorHandler]

'_________________________________________________________________
[EXTRACT.and.STORE.type.COMMAND] Skip=Skip+1
Err$="M [EXTRACT.and.STORE.type.COMMAND]<"+str$(Found-Skip)+">"
call logit Err$
print tab(Ln);Err$
If Found>Skip then GOTO [NextOperation]
    ' _________________________________________
    '/SETUP Variables                          \
        OFFSUB=0
        Scaned$=Fixed$
        Fixed$=InFile$+".05.Type.basJ"
    '\_________________________________________/


    ' ______________________________________________________
    '/OPEN Files for input and Output                       \
    Type$=CONVERT$+"UU.TYPEvariable.txt"
    open Type$ for output as #f7
    open CONVERT$+Fixed$ for OUTPUT as #f6
    open CONVERT$+Scaned$ for INPUT as #f5
    '\______________________________________________________/
    Remove1$=" type ": Remove2$=" end type "
    ' _________________________________________________________
        do until EOF(#f5)
    '----------------------------------------------------------
            line input #f5, xx$
            zz$=xx$ 'for problem$ output
            ' ______________________________________________________
            '/Does TYPE command on line exist?                      \
            Z=instr(xx$,Remove1$)'" type "
            '________________________________________________
            if Z>0 then '/TYPE found get statement\
               xx$=Isolate.Statement$ (Y1$, Y3$, xx$, Z)
               print 1,xx$

                '__________________________________________________________
                '/ Does string name Nm$ from xx$ exist?                 \
                Z=instr(xx$,Remove1$)+len(Remove1$) 'Does string name exist?
                Nm$=trim$(mid$(xx$,Z)): xx$="" 'Type name assigned to Nm$
                if len(trim$(Nm$))=0 then  'no name report error
                    Problem=Problem+1
                    Problem$(Problem)="<"+Remove1$+" Name not found! {"+zz$+"}>"
                    call logit Problem$(Problem)
                    exit do
                end if
                print 2,"[";Nm$;"]"
                '____________________________________________________
                '/Are there TYPE statment Variables with peramiters \
                if Y3$<>" '" then 'more peramiters on line
                    call Extract.Type.Paramiters Y3$,xx$,Nm$,zz$,Remove2$
                end if
                print 3,"[";Nm$;"]"
                '<---Continue getting Type Variables till xx$=end type --->
                if instr(xx$,Remove2$)=0 then 'end of type command?
                    OFFSUB=0
                    do until eof(#f5)
                        if xx$=Remove2$ then exit do
                        line input #f5, xx$: xx$=trim$(xx$)
                        Y3$=xx$: xx$=""
                        'print 7,"[";Nm$;"]","[";xx$;"]","[";Y3$;"]"
                        '-- check for long and String Variables --
                        call Extract.Type.Paramiters Y3$,xx$,Nm$,zz$,Remove2$
                        'print 8,"[";Nm$;"]","[";xx$;"]","[";Y3$;"]"
                    loop
                end if
            else
                if trim$(left$(xx$,1))<>"'" then xx$="' "+trim$(xx$)
                print #f6,xx$
            end if
        loop
   ' _________________
   '/Close OPEN Files \
        close #f5
        close #f6
        close #f7
   '\________________/
print "'here [EXTRACT.and.STORE.type.COMMAND]": end
' _________________________________________________
'/ SAVE LAST OUTPUT FILE TO CONTROLING TEXT FILE   \
   call Record.Repaired.Code
'\_________________________________________________/

'Record repair not working
Err$="{{ RUN JB Program Again! }}"
goto [ErrorHandler]


'_________________________________________________
[LOAD.random.FILE.with.BAS] Skip=Skip+1
Err$="M [LOAD.random.FILE.with.BAS]<"+str$(Found-Skip)+">"
call logit Err$
print tab(Ln);Err$
If Found>Skip then GOTO [NextOperation]
    ' _________________________________________
    '/SETUP Variables                          \
    Scaned$=Fixed$
    Fixed$=InFile$+".03.rand"
    '\_________________________________________/
    '__________________________________________
    [GET.number.OF.records.FOR.bas] Ln=Ln+2
    Err$="M [GET.number.OF.records.FOR.bas]<"+str$(Found-Skip)+">"
    call logit Err$
    print tab(Ln);Err$: Ln=Ln-2
    ' __________________________________________________________________
    '/open Random file to handle operations without reloading and saving\
    open CONTROL$+Fixed$ for random as #f10 len = 300  'RecordSize
    field #f10, 300 as BasRecord$
        ' ______________________________________________________________
        '/LOAD PB CODE LINES INTO RANDOM ARRAY and get number of records\
        open CONVERT$+Scaned$ for INPUT as #f11: RecordNumber=0
        do until eof(#f11)
            RecordNumber=RecordNumber+1
            line input #f11, BasRecord$: BasRecord$=trim$(BasRecord$)
            put #f10,RecordNumber
        loop
        close #f11
        '\______________________________________________________________/
        ' ______________________________________________________________
        '/Find Random Statements and PROCESS Related STATEMENTS         \
    [USE.random.TO.repair.RANDOM.bas]  Ln=Ln+2
    Err$="M [USE.random.TO.repair.RANDOM.bas]<"+str$(Found-Skip)+">"
    call logit Err$
    print tab(Ln);Err$: Ln=Ln-2
    cls
    '__________________________________________________________________
    gosub [Find.Type.Variable]
    Print 1,N,"Type Name: [";TypeVariable$;"]"
    get #f10,N : BasRecord$=trim$(lower$(BasRecord$))'fix up found random statement
    print 2,N,BasRecord$
    '__________________________________________________________________
    gosub [Find.Array.Variable]
    print 3,N,"Random Len value name: [";DimSize$;"]"
    print 4,A,"Array Storage Name: [";ArrayName$;"]"
    '__________________________________________________________________
    gosub [Assemble.Field.Statement]
close #f10
'\______________________________________________________________________/
[aa.working.end]    print "'here end [aa.working.end]": end
'________________________________________________
[Assemble.Field.Statement]  Ln=Ln+4
Err$="S [Assemble.Field.Statement]<"+str$(Found-Skip)+">"
call logit Err$
print tab(Ln);Err$: Ln=Ln-4
print

if (N>RecordNumber or A>RecordNumber or S>RecordNumber) or (S=0 or A=0 or N=0) then
    Problem=Problem+1
    Problem$(Problem)="<RecordNumber("+Str$(RecordNumber)+") > N="+str$(N)+_
    ", A="+str$(A)+", S="+str$(S)+">< OR (N,A,S) = 0>"
    call logit Problem$(Problem)
    print Problem$(Problem)
else
    get #f10,N : BasRecord$=trim$(lower$(BasRecord$)): print 1, N, " N [";BasRecord$;"]"
    print DimSize$
    get #f10,A : BasRecord$=trim$(lower$(BasRecord$)): print 2, A, " A [";BasRecord$;"]"
    print ArrayName$
    print AraySize$
    get #f10,S : BasRecord$=trim$(lower$(BasRecord$)): print 3, S, " S [";BasRecord$;"]"
    print TypeVariable$
    'open CONVERT$+"UU.TYPE.txt" for input as #f
    'does TypeVariable = Record
    'if yes Save Record
    'load record , dim record as ArrayName ArraySize
    '


end if
close #f10
[aa.working3]    print "'here end [aa.working3]": end
'OPEN y1$ FOR RANDOM AS 2 LEN = LEN(DUMMYpick)
'        picked(0).pk1 = a
'        picked(0).pk2 = b
'        picked(0).pk3 = c
'        picked(0).pk4 = d
'        picked(0).pk5 = e
'        picked(0).pk6 = f
'        PUT#2, six, picked(0)
'CLOSE 2
'adjust random File before moving on
'Field: get1, get2, etc
'then Array() = get1, get2 etc
'open type text get type name
'assemble Field and Len=
'assemble array
'output field and array

return
'________________________________________________
[Find.Array.Variable] Ln=Ln+4
Err$="S [Find.Array.Variable]<"+str$(Found-Skip)+">"
call logit Err$
print tab(Ln);Err$: Ln=Ln-4

    Find$="as global "+ TypeVariable$
    print 20,Find$: print
    For A=1 to RecordNumber
        get #f10,A : BasRecord$=trim$(lower$(BasRecord$))
        if instr(BasRecord$,lower$(Find$))>0 then
            print 21,BasRecord$
            print 21,"12345678901234567890123456789012345678901234567890"
            print
            Z=instr(BasRecord$,lower$(" DIM "))
            if Z>0 then
                S1=Z+5
                print 22,"Dim: ";S1
                Z=instr(BasRecord$,lower$(" ( "),Z)
                if Z>0 then
                    S2=Z
                    Z1=Z+2
                    print 23,"bracket1: ";S2,Z1
                    Z=instr(BasRecord$,lower$(" ) "),Z1)
                    if Z>0 then
                        Z2=Z
                        print 24,"bracket2: ";Z1,Z2
                        AraySize$=mid$(BasRecord$,Z1,Z2-Z1+1)
                        print 25,"[";AraySize$;"]"
                        ArrayName$=trim$(Mid$(BasRecord$,S1,S2-S1+1))
                        print 26,ArrayName$
                        [aa.working1]    print "'here end [aa.working1]": end
                        if len(trim$(AraySize$))>0 then return
                    end if


                end if
            end if

        end if
    next A
return
'_____________________________________________________
[Find.Type.Variable] Ln=Ln+4
Err$="S [Find.Type.Variable]<"+str$(Found-Skip)+">"
call logit Err$
print tab(Ln);Err$

    For N=1 to RecordNumber
        get #f10,N : BasRecord$=trim$(lower$(BasRecord$))
        if instr(BasRecord$,lower$(" RANDOM "))>0 then
            print 11,N,BasRecord$: print
            Z=instr(BasRecord$,lower$(" LEN "))
            if Z>0 then
                print 12,"Len: ";Z
                Z=instr(BasRecord$,lower$(" ( "),Z)
                if Z>0 then

                    print 13,N,"bracket1: ";Z
                    Z1=Z+2
                    Z=instr(BasRecord$,lower$(" ) "),Z1)
                    if Z>0 then
                        print 14,N,"bracket2: ";Z
                        Z2=Z
                        DimSize$=trim$(mid$(BasRecord$,Z1,Z2-Z1+1))
                        print 15,N,"[";DimSize$;"]"
                        print
                        gosub [Find.Dim.Size]
                        if len(trim$(TypeVariable$))>0 then Ln=Ln-4: return
                    end if


                end if
            end if

        end if
    next N
Ln=Ln-4: return
'___________________________________________________________
[Find.Dim.Size] Ln=Ln+4
Err$="S [Find.Dim.Size]<"+str$(Found-Skip)+">"
call logit Err$
print tab(Ln);Err$: Ln=Ln-4

Take$="' DIM "+DimSize$+" as global"
TypeVariable$=""
print "Find: ";Take$: print
for S=1 to RecordNumber
    get #f10,S : BasRecord$=trim$(lower$(BasRecord$))
    if instr(BasRecord$,lower$(Take$))>0 then
        TypeVariable$=trim$(mid$(BasRecord$,len(Take$)+2))
        if right$(TypeVariable$,1)="'" then TypeVariable$=trim$(left$(TypeVariable$,len(TypeVariable$)-1))
        print 10,"[";len(Take$);"]","[";TypeVariable$;"]"
        return
    end if
next S

return

'________________________________________________________________
junk=0 'needed to prevent weird syntax error when two Labels meet
'________________________________________________________
[NextOperation] 'place new operations after this line
'========================================================
RecordSize=310
'open InFile$+".ran.basL" for random as #f10 len = RecordSize ' open as random access
'field #f10, 256 as Record$, 50 as RecordSize$


'close #f10





junk=0: print "'here [NextOperation]": end
'===================================================
'___________________Method_Form_place in_[NextOperation]_________________________
'_____________________________________
[LABEL.FORM]
Err$="M [REMOVE.as.LONG]<"+str$(Found-Skip)+">"
call logit Err$
print tab(Ln);Err$

If Found>Skip then GOTO [NextOperation]
    ' _________________________________________
    '/SETUP Variables                          \
        OFFSUB=0
        Scaned$=Fixed$
        Fixed$=InFile$+".00.empty.basJ"
    '\_________________________________________/
    ' ______________________________________________________
    '/OPEN Files for input and Output                       \
        open CONVERT$+Fixed$ for OUTPUT as #f6
        open CONVERT$+Scaned$ for INPUT as #f5
    '\______________________________________________________/

   ' ________________
   '/                \
    do until EOF(#f5)
        line input #f5, xx$



    loop
   '\________________/
   ' _________________
   '/Close OPEN Files \
        close #f5
        close #f6
   '\________________/
   print "'here [REMOVE.as.LONG]": end
' __________________________________________________
'/ SAVE LAST OUTPUT FILE TO CONTROLING TEXT FILE    \
   call Record.Repaired.Code
'\__________________________________________________/
Err$="{{ RUN JB Program Again! }}"
goto [ErrorHandler]
' ______________________________________________________
'/END OF THIS PROGRAM, MORE STRUCTURAL WORK NEEDED BE IT\
'|FOR EITHER PYTHON OR JUST BASIC, DO NOT RUN AS EXE, IT |
'|IS CONSTRUCTED TO FIX CODE PROBLEMs AS ENCOUNTERED NEXT|
'|LOAD: [B-prep_Code TranslatePB-jb.basJ] to Continue    |
'|making changes to the PB code. It will use             |
'|[??.Scaned.Code.txt] to capture the PB File Name.      |
'========================================================

'______________________________________________________________________________|
print "  _____________________________________________________  "
print " / Preparation for Next Translating Code Complete!     \ "
print "| TO CONTINUE TRANSLATING Power Basic, Load into the    |"
print "| JUST BASIC Editor [BB-prep_Code Translate PB-jb.basJ] |"
print "| Then RUN Program in Editor                            |"
print " \_____________________________________________________/ "
print
print "Load and get base name add CC to front"
print "'here end": end
' __________________________________________
'/Setup files for saving completed prep AA  \
Scaned$=CONVERT$+Fixed$
Fixed$="CC."+InFile$
open "Load Last Translation.TXT" for append as #1
    print #1, Fixed$
close #1
'\__________________________________________/
   ' ___________________________________________________________________
   '/Save prepared file to Main Folder                                  \
      open Fixed$ for OUTPUT as #11
      open Scaned$ for INPUT as #10
    '\__________________________________________________________________/
   ' __________________________________________________________________
   '/Find Globals,output, then input, then save as single Global       \
     do until eof(#10)
        line input #10,xx$
        print #11,xx$
    loop
   ' _________________
   '/Close OPEN Files \
      close #10
      close #11
   '\_________________/
    '___________________________________________________________________
    [CONVERT.KILL.BASJ.FILES]
    dim info$(1,1) 'dim needed for info to gather file information
    files DefaultDir$+"\!CONVERT", "*.BASJ", info$() 'checks for BAS files
    Number=val(info$(0,0))
    if Number>0 then
        for F=1 to Number
            kill CONVERT$+info$(F,0)
        next F
    end if

'_________________________________________________________
[ErrorHandler] 'NOTIFICATION OF END OF EXECUTION OR ERROR \
'\__Place SUB OR FUNCTION CALLS here only when no error!__/
    Ln=0
    if Err>0 then
        print
        print " ___________________________________________"
        print "/          ERROR MESSAGE                    "
        if Err$<>"" then print "{"+Err$+"}"
        print "Error number is {";Err;"}"
        print "\__________END OF MESSAGE___________________"
    else
        print
        print " ___________________________________________"
        print "/          LAST PROCEDURE                   "
        print " {"+Err$+"}"
        print "\___________OR MESSAGE______________________"

       if Found>Skip then
            call logit "BB [END OF PROGRAM EXECUTION]"
            print " ___________________________________________"
            print "/          OUTPUTED FILE                   "
            print "   Program has Returned the Checked"
            print "   Code to Program ["+Fixed$+"]"
            print "\______________THE_END______________________"
        end if
    end if
    if Problem>0 then
        print " ___________________________________________"
        print "/          Code Problems Found              "
        print "   Some Code translations Failed!           "
        print "   See [BB.PB to JB.log.TXT]                "
        print "\________ Problem _ List ___________________"
        print
        for X=1 to Problem
            print tab(4);Problem$(X)
        next X
    end if


' __________________________________________________________________
'/  PROPER END TO PROGRAM EXECUTION AND ERROR HANDLING              \
                    END                                             '|
'|  3 RETURN without GOSUB                                           |
'|  4 Read past end of data                                          |
'|  8 Branch label not found                                         |
'|  9 Subscript out of range                                         |
'|  11 Division by zero                                              |
'|  53 OS Error: The system cannot find the file specified.          |
'|  58 OS Error: Cannot create a file when that file already exists. |
'|  55 Error opening file                                            |
'|  52 Bad file handle                                               |
'|  62 Input past end of file                                        |
'|                                                                   |
'\____________START OF FUNCTIONS AND SUBROTINES______________________/
'=====================================================================
'____________________________________________________
sub Record.Repaired.Code 'Fixed,CONVERT$ are Global
' __________________________________________________
'/Save to Controlling Text File                     \
open CONVERT$+"BB.Scaned.Code.txt" for append as #f2
    print #f2,Fixed$ 'last file created or repaired
close #f2
'\__________________________________________________/
end sub
'__________________________
[LOGtoCONTROLprocessedFILE]
sub logit itlog$
    itlog$=trim$(itlog$)
    open CONVERT$+"BB.PB to JB.log.TXT" for APPEND as #f1
        print #f1,SPACE$(Ln)+itlog$
    close #f1
end sub
'_______________________
function Ltrim$(String$)
    do until String$=Trim$(String$)
        if trim$(String$)="" then String$="": exit do
        If left$(String$,1)=space$(1) then String$=mid$(String$,2) else exit do
    loop
    Ltrim$=String$
end function
'_______________________
function Rtrim$(String$)
    do until String$=Trim$(String$)
        if trim$(String$)="" then String$="": exit do
        If Right$(String$,1)=space$(1) then
            String$=mid$(String$,1,len(String$)-1)
        else
            exit do
        end if
    loop
    Rtrim$=String$
end function

function InsideBrackets(xx$,Z) 'inside brackets
Err$="F InsideBrackets(xx$,Z)" 'Move past double quotes in xx$
IF OFFSUB=0 THEN
    Ln=Ln+4: call logit Err$ 
    print tab(Ln); Err$: Ln=Ln-4: OFFSUB=1
END IF
    InsideBrackets=0
    IF  Z = 0 THEN EXIT FUNCTION
    Y = 0 :  X = 0
    DO
        Y = INSTR(xx$,"(", X+1): if Y=0 then exit function
        X = INSTR(xx$,")", Y+1): if X=0 then exit function
    loop until (Z>Y and Z<X)
    InsideBrackets=Y
END function

'_______________________________________________
function Search.For.Ref$(Ref$,LastRecord)
Err$="Search_For_Ref("+Ref$+")"
IF OFFSUB=0 THEN
    Ln=Ln+4: call logit Err$ 
    print tab(Ln); Err$: Ln=Ln-4: OFFSUB=1
END IF

    Namey$=Ref$
    Namey=val(Ref$)

    TopRecord = 1
    BottomRecord = LastRecord
    do
        MidPoint = INT((TopRecord + BottomRecord) / 2)
        test = val(LEFT$(Record$(MidPoint),LEN(Namey$)))
        IF test = Namey THEN EXIT DO '---------------->
        IF Namey>test THEN
            TopRecord = MidPoint + 1
        ELSE
            BottomRecord = MidPoint - 1
        END IF
    LOOP UNTIL (TopRecord > BottomRecord)
      ' ______________________________________________________________________
      '/Found Record Set to value$ without Ref number                         \
        IF test = Namey THEN
            Search.For.Ref$=mid$(Record$(MidPoint),LEN(Namey$)+3)
        else
            Search.For.Ref$ ="No_Quote_Found"
        end if
      '\______________________________________________________________________/

END function

'______________________________________________
sub Return.Code.Quotes Scaned$,Fixed$,FileIn$
Err$="Return.Code.Quotes Scaned$,Fixed$,FileIn$"
IF OFFSUB=0 THEN
    Ln=Ln+4: call logit Err$ 
    print tab(Ln); Err$: Ln=Ln-4: OFFSUB=1
END IF

    ' _________________________________________________________
    '/ Load Record$() with Quote Records                       \
    open CONVERT$+FileIn$ for input as #f14
        N=0: do until eof(#f14): line input #f14,T$: N=N+1: loop
    close #f14

    Redim  Record$(N+1)
    open CONVERT$+FileIn$ for input as #f15
        N=0
        do until eof(#f15)
            line input #f15,T$: N=N+1
            Record$(N)=T$
        loop
    close #f15
    '\_________________________________________________________/

    LastRecord=N
   ' ________________________________________________________
   '/Search for Quote = ref points                           \
    open CONVERT$+Fixed$ for output as #f11
    open CONVERT$+Scaned$ for Input as #f10
   '\________________________________________________________/
        EmptyLines=0: FoundPlace=0 'Place limit of ref number
        do until eof(#f10)
            line input #f10,xx$
            Q=1 'set so loop works
            do until Q=0
                Q=instr(xx$,"quote$(",Q)
                if Q>0 then
                    S=Q+7 'start of ref #
                    R=instr(xx$,")",S)'end of number
                    P=R+1: R=R-1  'P right side of line, R end of number
                    RF=val(mid$(xx$,S,R-S+1)) 'ref value
                    Y1$=Left$(xx$,Q-1) 'left side of line
                    Y3$=mid$(xx$,P)    'right side of line
                    Namey$="0000000"+str$(RF)
                    Namey$=right$(Namey$,Place) 'place is length of Ref
                    Y2$=Search.For.Ref$(Namey$,LastRecord)
                    Q=S 'move search point just in case Y2$=""
                    if len(Y2$)>0 then
                        Y2$=chr$(34)+Y2$+chr$(34)
                        xx$=Y1$+Y2$
                        Q=len(xx$)
                        xx$=xx$+Y3$
                        QuotePlace=QuotePlace+1
                    else
                        EmptyQuotes=EmptyQuotes+1
                    end if
                end if
            loop
            print #f11,xx$
        loop
    ' _________________
    '/Close OPEN Files \
     close #f10
     close #f11
    '\_________________/
     if RemarkMissed>0 then print "Remarks Missed=";RemarkMissed
     Ln=Ln+4
     call logit "Quotes Missed=";EmptyQuotes
     call logit "Quotes Found=";QuotePlace
     Ln=Ln-8

end sub
'______________________________________________
sub Return.Code.Remarks Scaned$,Fixed$,FileIn$
Err$="Return.Code.Remarks Scaned$,Fixed$,FileIn$"
IF OFFSUB=0 THEN
    Ln=Ln+4: call logit Err$ 
    print tab(Ln); Err$: Ln=Ln-4: OFFSUB=1
END IF
    ' _________________________________________________________
    '/ How many records in Remark file                         \
    open CONVERT$+FileIn$ for input as #f14
        N=0: do until eof(#f14): line input #f14,T$: N=N+1: loop
    close #f14
    ' __________________________________________
    '/empty and size array for Search of Remarks\
            Redim  Record$(N+1)
    '\__________LOAD Record$()__________________/
    open CONVERT$+FileIn$ for input as #f15
        N=0
        do until eof(#f15)
            line input #f15,T$: N=N+1
            Record$(N)=T$
        loop
    close #f15
    '\_________________________________________________________/

    LastRecord=N 'number of records in array to be searched
   ' ________________________________________________________
   '/Search for Quote = ref points                           \
    open CONVERT$+Fixed$ for output as #f11
    open CONVERT$+Scaned$ for Input as #f10
   '\________________________________________________________/
        RemarkMissed=0: RemarkFound=0 'Holds record of search
       ' ________________________________________________________
       '/Return Remarks to BAS Code                              \
        do until eof(#f10)
            line input #f10,xx$
            Q=instr(xx$,": REMARK="): if Q=0 then Q=instr(xx$," REMARK=")
            '____________________________________________________________
            if Q>0 then
                do until Q=0 'error exit loop
            '___________Remark_Record_Found______________________________
                    S=Q: Q=0 'start of remark ref
                    R=instr(xx$,"=",S)+1 'start of ref number
                    if R=0 then exit do '---------------->
                    E=R+Place 'end of ref#
                    '__GET_REF_NUMBER_____________
                    Namey$=TRIM$(mid$(xx$,R,Place))
                    Y1$=Left$(xx$,S-1) 'left side of line
                    Y3$=mid$(xx$,S)    'eliminated right side of line
                    Y2$=Search.For.Ref$(Namey$,LastRecord)
                    if len(Y2$)>0 then
                        xx$=Y1$+Y2$
                        RemarkFound=RemarkFound+1
                    else
                        RemarkMissed=RemarkMissed+1
                    end if
                 loop
            end if
            '____________________________________________________________

            print #f11,xx$
        loop
       '\_As_Action_Code_ends_with_Remark_so_does_search_of_line_/
    ' _________________
    '/Close OPEN Files \
     close #f10
     close #f11
    '\_________________/
     if RemarkMissed>0 then print "Remarks Missed=";RemarkMissed
     Ln=Ln+4
     call logit "Remarks Missed=";RemarkMissed
     call logit "Remarks Found=";RemarkFound
     Ln=Ln-8

end sub

sub Extract.Type.Paramiters byref Y3$,byref xx$,byref Nm$,zz$,Remove2$
Err$="Extract.Type.Paramiters byref Y3$,byref xx$,byref Nm$,zz$,Remove2$"
IF OFFSUB=0 THEN
    Ln=Ln+4: call logit Err$ 
    print tab(Ln); Err$: Ln=Ln-4: OFFSUB=1
END IF
            print 9,"[";Nm$;"]","[";xx$;"]","[";Y3$;"]"
            '________________________________________________________
            do until len(trim$(Y3$))=0 '/Are there TYPE values in xx$\
                '<--- Separate out statements to right of colin ------>
                Z=instr(Y3$," : ",Z)        'Are there After statements?
                if Z>0 then                 'does [: right] line divide exists
                    xx$=left$(Y3$,Z)        'Left side with space at end
                    Y3$=trim$(mid$(Y3$,Z+2))':right side with quote
                else                       'no right statement extract quote
                    if right$(Y3$,1)="'" then Y3$=left$(Y3$,len(Y3$)-1)
                    if left$(Y3$,1)="'" then Y3$=mid$(Y3$,2)
                    xx$=Y3$
                    Y3$=""
                end if
                xx$=space$(1)+trim$(xx$)+space$(1) 'just in case a space missing


                if instr(xx$,Remove2$)>0 then    'Has the 'end type' been reached?
                    'print 10,"[";Nm$;"]","[";xx$;"]","[";Y3$;"]"
                    if Len(Y3$)>0 then  'output non type statement
                        Y3$="' "+trim$(Y3$)
                        print #f6,Y3$   'output right statement
                        Y3$=""
                    end if
                    print #f7,Nm$: Nm$=""
                    exit do 'with xx$ = end type
                end if
                '<--is there a variable type: long or string --------->
                Z1=instr(xx$," as long ")
                Z2=instr(xx$," as string ")
                Caseit=0
                'exclusion positional conditionals for CASE
                if Z1>0 and Z2=0 then Z=Z1: Caseit=1 'as long
                if Z2>0 and Z1=0 then Z=Z2: Caseit=2 'as string
                'print 5,Caseit,"[";Nm$;"]","[";xx$;"]",,"[";Y3$;"]"
                'print

                '___________________________________________________
[a.TYPE23]      SELECT CASE Caseit 'Extract TYPE name and peramiter
                CASE 1 'Add long value and peramiter to name?
                '---------------------------------------------------
                    Nm$=Nm$+","+trim$(left$(xx$,Z))+","+str$(Place)
                    xx$=""
                CASE 2 'Add string value and paramiter to name
                    X$=trim$(left$(xx$,Z))+"$": Nm$=Nm$+","+X$
                    Z1=instr(xx$,"*") 'is there parameter
                    if Z1>0 then 'dimention of string found
                        T=val(mid$(xx$,Z1+1))
                        If T=0 then T=Place
                    else
                        T=Place
                    end if
                    Nm$=Nm$+","+str$(T)
                    xx$=""
                CASE else
                    Z=instr(lower$(xx$),trim$(Remove2$))
                    if Z>0 then
                        xx$=Remove2$
                        if len(trim$(Y3$))>0 then
                            Y3$="' "+trim$(Y3$)
                            print #f6,Y3$: Y3$=""
                        end if
                        print #f7,Nm$: Nm$=""
                    else
                        xx$="4<ERROR>"+zz$+"<ERROR>"+xx$
                        print xx$
                        Problem=Problem+1: Problem$(Problem)=xx$
                        print #f6,xx$: xx$=""
                   end if
                   exit do
[a.TYPE24]      END SELECT

            loop
            'print 11,"[";Nm$;"]","[";xx$;"]","[";Y3$;"]"

end sub


function Isolate.Statement$ (byref Y1$, byref Y3$, xx$, Z)
Err$="Isolate.Statement$ byref Y1$, byref Y3$, xx$, Z"
IF OFFSUB=0 THEN
    Ln=Ln+4: call logit Err$ 
    print tab(Ln); Err$: Ln=Ln-4: OFFSUB=1
END IF
'TESTED with junk and works
'Isolates colin statements to the right and left of Z statement
'Z>len(xx$) will grab last statement, Z=0 will grab first statement
'Len(xx$)=0 will return xx$=Y1$ and Y3$
'sets Y1$= to left statements, Y3$= to right statements
'adds to Y1$, Y3$; may change value for Y1$,Y3$ to " '"
'XX$ will have spaces on each side so it can be searched properly
'==============================================================
'_________________________________________
    if Z=0 then Z=1
    xx$=trim$(xx$)
    '________________________________________
    '/isolate Right of Z statement\
    Z2=instr(xx$," : ",Z) 'Is there statement after Z
    '______________________________________________________
    if Z2>0 then '/right colin side of line found\
    '--------------------------------------------------------
        Y$=trim$(mid$(xx$,Z2)): Y3$=trim$(Y3$) ' ?? : xx$ Z:2 Y3$ '
        if right$(Y$,1)="'" then Y$=trim$(left$(Y$,len(Y$)-1))
        if len(trim$(Y3$))=0 then Y3$="'"
        Y3$=Y$+space$(1)+Y3$ '?? : xx$ [: Y3$ ']
        xx$=trim$(left$(xx$,Z2))' ?? : xx$ 
    else
        if len(trim$(Y3$))=0 then Y3$=" '" 'create right side space
    '--------------------------------------------------------
    end if
    '_______________________________________________
    Z2=0:Lc=0'/isolate Left of Z statements\
    if left$(xx$,1)="'" then xx$=trim$(mid$(xx$,2))
    '_________________________________________________
    do '/move from left to right looking for colin\
    '----------------------------------------------------------------
        Z2=instr(xx$," : ",Z2+1): if (Z2<Z and Z2>Lc) then Lc=Z2+2 'last colin before Z
    '----------------------------------------------------------------
    loop until Z2=0
    '______________________________________________________
    if Lc>0 then '/Isolate left colin statement\
    '------------------------------------------------------

        Y1$=trim$(Y1$): if len(Y1$)=0 then Y1$="'"

        Y1$=Y1$+space$(1)+trim$(Left$(xx$,Lc)) 'left side to colin
        xx$=trim$(mid$(xx$,Lc)) 'right side of colin
    '-----------------------------------------------
    else
    '----------------------------------------------
        if Len(trim$(Y1$))=0 then Y1$="' " 'no left side statements
    '-----------------------------------------------
    end if
    [output.total.line]
    '______________________________________________________________
    if len(trim$(xx$))=0 then '/combine right and left statements\
        Z$=trim$(Y1$)+" : "+trim$(Y3$): Y3$="": Y1$=""
        do
            Z=instr(Z$,": :")
            if Z>1 then
                Z=Z+1
                A$=left$(Z$,Z)
                Z=Z+2
                B$=mid$(Z$,Z)
                Z$=A$+B$ 
            end if
            T=instr(Z$,"  ")
            if T>1 then
                A$=trim$(left$(Z$,T)) 'captures space
                T=T+1
                B$=trim$(mid$(Z$,T))
                Z$=A$+space$(1)+B$
                Z=T
            end if

        loop until Z=0
        do
            X$=left$(Z$,1)
            if X$="'" or X$=":" then
                Z$=trim$(mid$(Z$,2))
            else
                X$=right$(Z$,1)
                if X$="'" or X$=":" then
                    Z$=trim$(left$(Z$,Len(Z$)-1))
                else
                    X$=""
                end if
            end if
        loop until X$=""
        xx$="' "+Z$+" '"
    else
        do
            Z=(left$(xx$,1)=":" or left$(xx$,1)="'"): if Z>0 then xx$=trim$(mid$(xx$,2))
            if Z=0 then Z=(right$(xx$,1)=":" or right$(xx$,1)="'"): if Z>0 then xx$=trim$(left$(xx$,len(xx$)-1))
        loop until Z=0
        xx$=space$(1)+xx$+space$(1)
    end if
    Isolate.Statement$=xx$
end function













































































































































































































































































































































































































































































