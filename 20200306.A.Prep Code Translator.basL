[code.Descriptive.Outline]
mainwin 80 30
'bug once you open a file with a #10 you must keep
'opening it with that #10 or 'SYNTAX ERROR
'you can not have two labels together without an operation
'undo last does not return last line entry

'02040608101214161820222426283032343638404244464850525456586062646668707274767880
' Note: Front is Western Courier New regular 10
'       Using Under Score _ try to keep CODE Lines under 80. This allows other
'       reference window; [AA_Convert_PB-JB.log.TXT]; to be used while Coding.

' PB Syntax JB Fix: INSTR(string1, string2[, starting])
'  ___________________________________________________________________________
' /                                                                           \
'| PB to JB TRANSLATION_AID.BAS                                                |
'| 1. Hugh Polley   2020/02/04                                                 |
'|                                                                             |
'| This code is to be considered "public domain".' Feel free to do what you    |
'| want with it. If you come with an improvement please post it here so all    |
'| Basic users get the benefit.                                                |
'| If you make changes to the CODE add your name and date to above listing!    |
'|                                                                             |
'| Disclaimer:                                                                 |
'| This code is provided as-is and it does not have any warranty of any kind.  |
'| User is responsible for any misuse of the code. Do not use this code in     |
'| whole or in part if you can not accept these terms!                         |
' \___________________________________________________________________________/
'
'  ___________________________________________________________________________
' /                                                                           \
'|Purpose: Translation Code Outline for Power Basic BAS files to Just Basic    |
'|    or: Translation Code Outline for Power Basic BAS files to Python Basic   |
' \___________________________________________________________________________/
'
'  ___________________________________________________________________________
' /                                                                           \
'|       MY PAST TRANSLATE PROGRAMS HAD ONE OR MORE OF THESE METHODS           |
'| NOTE: To Accomplish (1-12) run program again as required after each Step    |
'|01. Set [InFile$=PB_file] with (.BAS)] extension                             |
'|02. Allow Program to Create a [!CONTROL] and a [!CONVERT] sub directory!     |
'|03. Place a copy of the [InFile$ .BAS] Program code in [!CONVERT] directory  |
'|04. Program will create an Execution LOG File in CONVERT [AA_PB->JB.log.TXT  |
'|05. Program Creates [AA.Scaned.Code.txt] for last update to converted File!  |
'|    NOTE: control what is executed by deleting records from bottom to top!   |
'|06. Remove LABELS <??##?:> and change to [??##?] Save to Labels.txt          |
'|    At same time GOSUB and GOTO branches are repaired
'|07. Remove Remarks by replacing them with [:REMARK=#####] TO SPELLremarks.TXT|
'|08. Remove Quotes by replacing them with [quote$(#####)] to SPELLquotes.TXT  |
'|09. To aid in searching for Power Basic Functions and Commands Colins and    |
'|    operators are SPACED! change [?:?] to [? : ?], [?,?] to [? , ?] etc      |
'|10. To Aid in testing of Code changes, Create REM quote + [Space] at the     |
'|    start of each line and a [Space] + REM Quote at end of each line         |
'|11. For each Syntax Change Have Scaned$ = Fixed$, Fixed$=new fix             |
'|    [OPEN Fixed$ FOR OUTPUT] and [OPEN Scaned$ FOR INPUT]                    |
'|12. Highlight lines which need Manual Fix with [< line >]                    |
'|13. For PYTHON Highlight GOTO and Line they branch to with the same Number   |
'|     <## ?? ?> Most can be fixed with DO-LOOP or/and IF-THEN-ELSE and/or     |
'|    CALL or RETURN Subroutine                                                |
'|=============================================================================|
'|Note: back when computer memory was a problem I did [10-12] with READ and    |
'|   DATA statements. Line Numbers and GOTO, GOSUB also required a rework      |
'|exp. Change required GOTO,GOSUB [###], statements that have a value greater  |
'|    than zero! exp. VAL("100") > 0 so change to VAL("z100") = 0  GOSUB 100   |
'|    becomes GOSUB z100                                                       |
' \___________________________________________________________________________/
'
on error goto [Error.Handler]
GLOBAL InFile$,CONTROL$,CONVERT$,Fixed$,Scaned$,Skip
GLOBAL Structure, Syntax, Found, Place, Ln, SUBOFF, SUB1OFF, SUB2OFF
GLOBAL f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,f14 'open file values
'_____________SET_FILE_NUMBERS________________________________________
f1=1: f2=2: f3=3: f4=4: f5=5: f6=6: f7=7: f8=8: f9=9: f10=10
f11=11: f12=12: f13=13: f14=14
Place=5: Ln=0 'Size of Reference Numbers!
Skip=0: Found=0 'recording how many procedures
SUBOFF=0: SUB1OFF=0: SUB2OFF=0
'______________________________________________________________________________|
[OUTPUT.settings.FOR.files.AND.lines] Skip=0
Err$="SET [OUTPUT.settings.FOR.files.AND.lines]<"+str$(Skip)+">"
Err0$=Err$
    CONTROL$="!CONTROL\"
    CONVERT$="!CONVERT\"
    Ln=1
    CLS: print: print tab(Ln);Err$
'______________________________________________________________________________|
[DOES.subdiectory.!CONTROL.exist] Skip=Skip+1
Err$="SET [DOES.subdiectory.!CONTROL.exist]<"+str$(Skip)+">"
Err1$=Err$
print tab(Ln);Err$
    result = mkdir( "!CONTROL")
    if result <> 0 then
        print "|_____________________________________|"
        print "| [!CONTROL] directory EXISTS !       |"
        print "| Working Directory for .temp Files!  |"
        print "|-------------------------------------|"
    else
        print "|_____________________________________|"
        print "| [!CONTROL] directory CREATED!       |"
        print "| Working Directory for temp Results! |"
        print "|-------------------------------------|"
        print
        Err$= " {{RUN JB Program Again! }}"
        goto [Error.Handler]
    end if

'______________________________________________________________________________|
[DOES.subdirectory.!CONVERT.exist] Skip=Skip+1
Err$="SET [DOES.subdirectory.!CONVERT.exist]<"+str$(Skip)+">"
Err2$=Err$
print tab(Ln);Err$
    result = mkdir( "!CONVERT")
    if result <> 0 then
        print "|_________________________________________________|"
        print "| [!CONVERT] directory EXISTS!                    |"
        print "| Working Directory for Translation Files !       |"
        print "|-------------------------------------------------|"
        print
    else
        print "|_________________________________________________|"
        print "| [!CONVERT] directory CREATED!                   |"
        print "| Working Directory for Translation Files !       |"
        print "|-------------------------------------------------|"
        print
        Err$=" {{ RUN JB Program Again! }}"
        goto [Error.Handler]
    end if
[InFile.IS.in.CONVERT] Skip=Skip+1
Err$="SET [InFile.IS.in.CONVERT]<"+str$(Skip)+">"
Err3$=Err$ 
print tab(Ln);Err$ 
[Get.From.Translation.txt.BAS.file.TO.be.CONVERTED]
Err$="SET [Get.From.Translation.txt.BAS.file.TO.be.CONVERTED]"
print tab(Ln+4);Err$ 
    ' ____________________________________________________________
    '/Translated Just Basic Code Files                            \
    open "Load Last Translation.TXT" for append as #f1: close #f1
    open "Load Last Translation.TXT" for input as #f2
    '\____________________________________________________________/
        Found=0'number of files found used to avoid translating more than needed
        InFile$="" 'will hold last record in file for procedure Found>skip?
        '____________________________________________________________
        do until eof(#f2)
            input #f2,X$
            IF instr(UPPER$(X$),".BAS")>4 THEN InFile$=X$: Found=Found+1
        loop
     ' ___________________________________________________________
     '/ Last file in Text File with extension of .BAS is used     \
     close #f2
     '\___________________________________________________________/
    if Found<>1 then 'corrupt or empty file
        '________________________________________________________
         do'/Get File Name or Loop until [enter] pressed         \
            cls: print
            Err$="<ERROR>Corrupt [Load Last Translation.TXT] File!<ERROR>"
            print tab(Ln+4);Err$
            print "Files Found=(";Found;") there should be 1"
            print "<Last file found: ";X$;">"
            print tab(Ln+4);
            input "Name of [PowerBasic.BAS] File to be Converted to JB?: ";X$
            if ASC(X$)=0 then print "Execution ended with press of [ENTER]": END
            if upper$(right$(X$,4))<>".BAS" then X$=X$+".BAS"
        LOOP until instr(UPPER$(X$),".BAS")>4
        '\________________________________________________________/
        open "Load Last Translation.TXT" for output as #f3
            print #f3,X$
        close #f3
        Err$="File Name: [";X$;"] Placed in Translation Text File!"
        print tab(Ln+4);Err$ 
        Err$=" {{ RUN JB Program Again! }}"
        goto [Error.Handler]
    else
        [try1START] on error goto [try1CATCH1]
            open CONVERT$+"AA."+InFile$ for input as #f3: close #f3
            goto [try1END] 'file exists!
        [try1CATCH1] on error goto [try1CATCH2]
            open InFile$ for input as #f4
            open CONVERT$+"AA."+InFile$ for output as #f5
                do until eof(#f4)
                    line input #f4,Record$
                    print #f5, Record$
                loop
            close #f4
            close #f5
            on error  goto [Error.Handler]
            Err$="SET File: ["+InFile$+"] Loaded into Folder CONVERT!"
            print Err$
            Err$=" { File Error Corrected { RUN JB Program Again! }}"
            goto [Error.Handler]
        [try1CATCH2] on error goto [Error.Handler]
            print "< DELETE [LOAD LAST TRANSLATION.TXT] AS >"
            Err$="<ERROR> PB File Not Found in Root Folder! <ERROR>"
            goto [Error.Handler]
        [try1END] on error goto [Error.Handler] '!CONVERT Power Basic Program exist
    end if

'______________________________________________________________________________|
[CLEAR.and.CREATE.logfile]  Skip=Skip+1
Err$="SET [CLEAR.and.CREATE.logfile]<"+str$(Skip)+">"
print tab(Ln);Err$
    ' ___________________________________________________
    '/Create procedure Log File                          \
    open CONVERT$+"AA.PB to JB.log.TXT" for output as #f1
    '\___________________________________________________/
        PRINT #f1,"<AA."+InFile$+">"
        print #f1, Err0$
        print #f1, Err1$
        print #f1, Err2$
    close #f1
    '\___________________________________________________/
    call logit Space$(Ln)+Err$ 'Line Indent

'______________________________________________________________________________|
[in.!CONVERT.find.LAST.bas] Skip=Skip+1
Err$="SET [in.!CONVERT.find.LAST.bas]<"+str$(Skip)+">"
call logit space$(Ln)+Err$
print tab(Ln);Err$
    dim info$(1,1) 'dim needed for info to gather file information
    files DefaultDir$+"\!CONVERT", "AA.*.BAS", info$() 'checks for BAS files
    Number=val(info$(0,0))
    '___________________________________________________________
    if Number<>1 then '/Right BAS file not found in Folder?     \
        if Number>1 then Err$="<More than one BAS File In Folder!>"
        if Number<1 then Err$="<No BAS File In Folder!>"
        call logit space$(Ln)+Err$
        print space$(Ln)+Err$
        print "|_________________________________________________|"
        print "|   Program BUG or OPERATOR ERROR In              |"
        print "|   [!CONVERT] directory                          |"
        print "|-------------------------------------------------|"
        print "| <There Should Be Only [AA.";InFile$;"]>"
        print "|_________________________________________________|"
        print
        Err$="<Delete Folder ["+CONVERT$+"] And [?? Translation.TXT]>"
        goto [Error.Handler]
    end if
'______________________________________________________________________________|
[CHECK.for.LAST.completed.CODE.scan] Skip=Skip+1
Err$="SET [CHECK.for.LAST.completed.CODE.scan]<"+str$(Skip)+">"
call logit space$(Ln)+Err$
print tab(Ln);Err$

    ' ____________________________________________________________
    '/Translated Just Basic Code Files                            \
    open CONVERT$+"AA.Scaned.Code.txt" for append as #f2: close #f2
    open CONVERT$+"AA.Scaned.Code.txt" for input as #f2
    '\____________________________________________________________/
        Found=0'number of files found used to avoid translating more than needed
        Fixed$="" 'will hold last record in file for procedure Found>skip?
        '____________________________________________________________
        do until eof(#f2)
            input #f2,X$ 
            if len(trim$(X$))>0 then Fixed$=X$: Found=Found+1
        loop
        '-----------------------------------------------------------
     close #f2
     '\___________________________________________________________/
    if len(trim$(Fixed$))=0 then
        open CONVERT$+"AA.Scaned.Code.txt" for output as #f2
            print #f2,"AA."+InFile$ 
        close #f2
        Err$="<PLACED [AA.";InFile$;"] into [AA.Scaned.Code.txt]!>"
        print tab(Ln+4);Err$
        Err$="{{ RUN JB Program Again! }}"
        goto [Error.Handler]
    else
        print tab(Ln);Fixed$+": <# Files Found=";Found;">"
    end if
' _____________________________________________________________________________
'/From this point on Fixed$ is used for File output; Scaned$ is used for File  \
'|input, eg. Scaned$=Fixed$, Fixed$=InFile$+##+des.basJ                         |
'|At this point in Code Skip is = 0, Skip/Found controls where you are at in    |
'|Translation Process! Mess with above Code at your own Risk!     |             |
  Skip=0: print "Decreasing number for each adjustment < -- >": Ln=Ln+4
'\_____________________________________________________________________________/
'______________________________________________________________________________|
[REMOVE.remarks.TO.spell] Skip=Skip+1
Err$="M [REMOVE.remarks.TO.spell]<"+str$(Found-Skip)+">"
call logit space$(Ln)+Err$
print tab(Ln);Err$
If Found>Skip then GOTO [REMOVE.quotes.TO.spell]
    ' _________________________________________
    '/SETUP Variables                          \
        SUBOFF=0
        REMARK=0
        Scaned$=Fixed$
        Fixed$=InFile$+".01.Remark.basJ"
    '\_________________________________________/
    ' ______________________________________________________
    '/OPEN Files for input and Output                       \
        open CONVERT$+"YY_Spell Remarks.TXT" for OUTPUT as #f4
        open CONVERT$+Fixed$ for OUTPUT as #f6
        open CONVERT$+Scaned$ for INPUT as #f5
    '\______________________________________________________/

   ' __________________________________________________
   '/Each line inputed, trimed and Rems removed to file\                \
    do until EOF(#f5)
        line input #f5, xx$: xx$=trim$(xx$)
        '======================
        if left$(trim$(xx$),1)="'" then 'line Remark found
        '-------------------------------------------------
            REMARK=REMARK+1
            Remarkit$=GetNextNumber$(REMARK)
            print #f4, Remarkit$+space$(2)+Rtrim$(xx$)
            print #f6, "REMARK="+trim$(Remarkit$)
        else
        '-------------------------------------------------
            Z=1: Quote$=""
           ' ______________________________________
           '/search for Rem outside of double Quote\
            do until Z=0
                Z = INSTR(xx$,"'",Z)
                if Z=0 then
                '----------------
                    print #f6,xx$ 'print code line
                    exit do '---------------------->
                '-----------------
                end if
                '==============================================================
                InQuote=InsideQuotes(xx$,Z) 'Function returns spot after Quotes
                '----------------------------------------
                if InQuote>Z then 'REM inside a quote found
                '------------------------------------------
                    Z=InQuote 'move along line
                else 'extract line and output remark
                    yy$=trim$(mid$(xx$,Z))
                    xx$=Left$(xx$,Z-1)
                    REMARK=REMARK+1
                    Remarkit$=GetNextNumber$(REMARK)
                    print #f4, Remarkit$+space$(2)+trim$(yy$)
                    print #f6, xx$+" : REMARK="+trim$(Remarkit$)
                    exit do '----------------------------------------->
                '-------------------------------------------
                end if
            loop
            '\_______________________________________/
        '---------------------------------------------------
        end if

    loop
   '\________________/
   ' _________________
   '/Close OPEN Files \
        close #f6
        close #f5
        close #f4
   '\________________/

' __________________________________________________
'/AVE LAST OUTPUT FILE TO CONTROLING TEXT FILE      \
   call Record.Repaired.Code
'\________[REMOVEquotesTOspell]____________________/
Err$="{{ RUN JB Program Again! }}"
'________________________________________________________________
goto [Error.Handler]
'________________________________________________________________|
[REMOVE.quotes.TO.spell]  Skip=Skip+1
Err$="M [REMOVE.quotes.TO.spell]<"+str$(Found-Skip)+">"
call logit space$(Ln)+Err$
print tab(Ln);Err$
    If Found>Skip then GOTO [REPAIR.labels.FROM.colin.TO.bracket]
    ' _________________________________________
    '/SETUP Variables                          \
        SUBOFF=0
        Quote=0
        Quote$="Quote$(??)"
        Scaned$=Fixed$
        Fixed$=InFile$+".02.Quote.basJ"
    '\_________________________________________/

   ' ______________________________________________________
    '/OPEN Files for input and Output                       \
        open CONVERT$+"XX-Spell Quotes.TXT" for OUTPUT as #f9
        open CONVERT$+Fixed$ for OUTPUT as #f7
        open CONVERT$+Scaned$ for INPUT as #f8
    '\______________________________________________________/
   ' _________________________________________________
   '/Replace Double Quotes with quote$(#+1) and record\
    Quote=0
    do until EOF(#f8)
        '----------------------------------------------
        line input #f8, xx$: Z=1 'start of line
        '_____________________________________________________
         do until Z=0 '/check each line until no Quote        \
            Z = INSTR(xx$,chr$(34),Z) 'find quote
            if Z=0 then 'record line in lower case
            '-------------------------------------
                print #f7,trim$(lower$(xx$))
                exit do '----------->
             end if
             Start=Z: Z=Z+1
             if ASC(mid$(xx$,Z,1))=34 then 'double empty quote found
             '------------------------------------------------
                Z=Z+1 'move along line
             else 'find closing Quote
             '------------------------------------------------
                InQuote=InsideQuotes(xx$,Z) 'byref xx$ unclosed quotes closed
                if InQuote>Z then 'position after closing Quote Found
                '---------------------------------------------
                    Last=InQuote-1 'get position of Quote
                    Z=InQuote 'continue quote line check
                    Y1$=Left$(xx$,Start-1) 'position before quote
                    yy$=mid$(xx$,Start+1,Last-Start-1) 'Quote without Quote marks
                    Y3$=trim$(mid$(xx$,Last+1)) 'Line After Quote
                    Quote=Quote+1: Quote$=GetNextNumber$(Quote)
                    yy$=Quote$+space$(1)+"'"+yy$+"'" 'for recording of quotes with spaces
                    '-------------------------------------------
                    print #f9,yy$ 'Quote reference recorded
                    '---------------------------------------------
                    Y2$=" quote$("+Quote$+") " 'code reference replaces Quote
                    '-----------------------------------------
                    xx$=Rtrim$(Y1$)+Y2$: Z=len(xx$)+1 'Z moved along line
                    '------------------------------------------
                    xx$=(xx$+Y3$) 'line reformed with Quote reference
                    '-------------------------------->
                else 'unlikely Code Problem?
                        cls
                        xx$="<ERROR unexpected>"+xx$+"<ERROR>"
                        print xx$
                        print #7,xx$
                        input "hit TO CONTINUE";T$
                        call logit xx$
                        Z=0
                 end if
             end if

         loop
        '\____________/


        '---------------------------------------------------
    loop
   '\________________/
   ' _________________
   '/Close OPEN Files \
        close #f7
        close #f8
        close #f9
   '\________________/

' __________________________________________________________________
'/                                                                  \
if  REMARK>Quote then Dim Record$(REMARK+1) else Dim Record$(Quote+1)
'\__________________________________________________________________/
' __________________________________________________
'/ AVE LAST OUTPUT FILE TO CONTROLING TEXT FILE     \
    call Record.Repaired.Code
'\___________[REPAIRlabelsFROMcolinTObracket]_______/
Err$="{{ RUN JB Program Again! }}"
'______________________________________
goto [Error.Handler]
'______________________________________
Function GetNextNumber$(Number)
    Number$="0000000"+str$(Number)
    GetNextNumber$=right$(Number$,Place)
end function
'______________________________________________________________________________|
[REPAIR.labels.FROM.colin.TO.bracket] Skip=Skip+1
Err$="M [REPAIR.labels.FROM.colin.TO.bracket]<"+Str$(Found-Skip)+">"
call logit space$(Ln)+Err$
print tab(Ln);Err$
If Found>Skip then GOTO [SPACE.it.FOR.searches]  'skip to next Task

    ' __________________________________________________
    '/Construct Settings to extract colin labels [##hh:]\
        SUBOFF=0 'turn off log repeats
        Scaned$=Fixed$
        Fixed$=InFile$+".03.Labels.basJ"
    '\__Colin_Labels_Turned_into_box_Labels_[_?_]_______/
    ' _____________________________________________
    '/                                             \
      open CONVERT$+"ZZ_Labels.TXT" for OUTPUT as #21
      open CONTROL$+Fixed$+".temp" for OUTPUT as #11 'temperary code hold
      open CONVERT$+Scaned$ for INPUT as #10 'raw power basic file
    '\_____________________________________________/

        do until EOF(#10) 'search records loop
            ' __________________________________________________________________
            '/search each line for Colin Label                                  \
            line input #10, xx$ 'line record
            '-------------------------------------------------------------------
            if left$(trim$(xx$),1)="'" then goto [do.1.again] 'line remark found
            ' __________________________________________
            '/Check for colin in line record            \
            Colin=INSTR(xx$,":")
            if Colin=0 then goto [do.1.again] 'no Colin in line record exit
            ' _______________________________________________________________
            '/Investigate record for criteria which matches with colin label \
            Z=Colin 'is first Colin found inside a double quote?
            InQuote=InsideQuotes(xx$,Z) 'byref xx$: unclosed quotes closed
            if InQuote=0 then 'colin not inside a Quote
                '___Move_Past_serial_spaces__________________
                for T=1 to Colin 'move past spaces
                    if mid$(xx$,T,1)<>space$(1) then exit for
                next T
                if T<Colin then
                    ' ______________________________________________________
                    '/  possible Label Found else bad line found            \
                    for X=T to Colin 'test for alfa numeric chr to Colin
                        yy$=mid$(xx$,X,1)
                        Y=asc(upper$(yy$)) 'for purpose of test
                        Z=(Y>64 and Y<91) or (Y>47 and Y<59) or Y=95'underscore
                        if Z=0 then exit for 'Space of othe chr found before colin
                    next X
                    if Z=0 then goto [do.1.again] 'non alfa found before colin
                    ' ___________________________________________________
                    '/ Label Found? , fix and record?                    \
                     yy$=upper$(left$(xx$,Colin-1))  'extract label without colin
                    ' __________________________________________________
                    '/ Test For not Label but Command                   \
                    restore [COMMAND.test]
                    [COMMAND.test]'some commands will have colin without space
                    data "CLS","LOOP","END","CLOSE","ENDIT" 'here data
                    D$=""
                    do until D$="ENDIT"
                        read D$
                        if D$=UPPER$(trim$(yy$)) then exit do
                    loop
                    If D$<>"ENDIT" then goto [do.1.again] 'a command was found
                   ' ______________________________________________
                   '/ repair xx$ and record Label                  \
                    xx$=mid$(xx$,Colin+1)   'beyond colin side of line
                    print #21,trim$(yy$)    'record label
                    'surround label yy$ with spaces for search
                    xx$=Space$(1)+yy$+space$(2)+xx$ 
                    goto [do.1.again] 'to print out repaired line
                end if
            end if

            '____________________________________
            [do.1.again] 'replaces nested If ENDif
            print #11,xx$ 'prints to CONTROL$
           '\___Labels_Repaired_and_Recorded_______________________________/
        loop

    ' __________
    '/          \
      close #10
      close #11
      close #21
    '\__________/
    '______________________________________________________________________________|
[FIX.found.LABELS.and.COLIN] 'no skip as second part of procedure
Err$="M [FIX.found.LABELS.and.COLIN]<"+Str$(Found-Skip)+">"
Ln=Ln+4: call logit space$(Ln)+Err$: Ln=Ln-4
print tab(Ln);Err$ 'second part of Label Repair
print "<!This will take some time! Go have a coffee!>"
SUBOFF=0: SUB2OFF=0
' ____________________________________________
'/Open Temp Repaired File and Continue Repairs\
 open CONVERT$+Fixed$ for OUTPUT as #11
 open CONTROL$+Fixed$+".temp" for INPUT as #10
'\____________________________________________/
    do until EOF(#10)
  ' ____________________________________________
  '/Seperate and Store Remarks                  \
        line input #10, xx$
       ' ___________________________________________
       '/Test for remark inside Quotes              \
        yy0$="":yy1$="":yy2$="":Q=1
        do until Q=0 'seperate out remark
            Q=INSTR(xx$,"'",Q) 'position of Quote
            '------------------------------------
            if Q>0 then 'is Rem inside Quote
                InQuote=InsideQuotes(xx$,Q) 'byref xx$ unclosed quotes closed
                '=======================
                if InQuote>Q then
                    Q=InQuote
                else 'Quote mark found
                    yy0$=mid$(xx$,Q)    'remark
                    xx$=left$(xx$,Q-1)  'before remark
                    exit do
                end if
                '=======================
            end if
            '------------------------------------
        loop
       '\___________________________________________/

        ' ______________________________________
        '/colin add Spaces to each side of Colin\
        Z=1: do until Z=0
            '-------------------------------------
            Z=INSTR(xx$,":",Z) 'position of Colin
            if Z>0 then 'Does Colin needs repair?
                InQuote=InsideQuotes(xx$,Z) 'byref xx$ unclosed quotes closed
                '====================================
                if InQuote>Z then 'quote mark inside quotes
                    Z=InQuote 'continue with check
                else
                    '================================
                    if mid$(xx$,Z-1,1)=space$(1) then 'extract left side colin
                        yy1$=left$(xx$,Z-2)
                    else
                        yy1$=left$(xx$,Z-1)
                    end if
                    '================================
                    if mid$(xx$,Z+1,1)=space$(1) then   'extract right side of colin
                        yy2$=mid$(xx$,Z+2)
                    else
                        yy2$=mid$(xx$,Z+1)
                    end if
                    ' _______________________________________________________
                    '/Reset Z for further check, repair xx$ with colin spaces\
                    yy1$=yy1$+" : "
                    xx$=yy1$+yy2$
                    Z=len(yy1$)
                end if
                '=====================================
            end if
            '--------------------------------------
        loop
       '\________________________________________/

       ' ___________________________________
       '/Load check and repair branch labels\
        open CONVERT$+"ZZ_Labels.TXT" for INPUT as #20
       '\___________________________________/
           ' _______________________________
           '/                               \
            DO UNTIL eof(#20)
                INPUT #20,Label$: Z=1: Label$=trim$(Label$)
                Replace.Label$=" ["+replstr$(Label$, "_", ".")+"] "

                Label$=space$(1)+Label$+space$(1)
                Z=1:tt$=space$(1)+xx$+space$(1)
               ' ________________________________
               '/ Replace Labels till none found \
                Z=1: do until Z=0
                    Z=INSTR(upper$(tt$),upper$(Label$),Z)
                    '----------------------------------------------
                    IF Z>0 THEN
                        E=Z+len(Label$) 'check for whole label word
                        '================================
                        yy1$=(left$(tt$,Z))
                        yy2$=mid$(tt$,E)
                        xx$=yy1$+Replace.Label$
                        Z=len(xx$)
                        xx$=xx$+yy2$
                        '==================================
                    end if
                    '--------------------------------------------
                LOOP
               '\________________________/

            loop
            '\_______________________________/
       ' ___________
       '/           \
        close #20
       '\___________/

        if len(yy0$)>0 then xx$=xx$+yy0$ 'remark exist
        print #11,xx$

    loop
   '\_______________________/

' ______________________
'/                      \
 close #10
 close #11
'\______________________/

' __________________________________________________
'/Save to Scanned Controlling Text File             \
  call Record.Repaired.Code
'\_______[SPACEitFORsearches]_______________________/
Err$="{{ RUN JB Program Again! }}"
'______________________________________________________________________________
goto [Error.Handler] 'each repair requires rerun in case some Manual repair wanted

'______________________________________________________________________________|
[SPACE.it.FOR.searches] Skip=Skip+1
Err$="M [SPACE.it.FOR.searches] <"+str$(Found-Skip)+">"
call logit space$(Ln)+Err$
print tab(Ln);Err$
If Found>Skip then GOTO [structure.REMOVE.lines]
print tab(Ln);"<Space It Repairs Underway, Please Wait!>"
    '_______________________________________
    SUB1OFF=0
    Scaned$=Fixed$
    Fixed$=InFile$+".04.Spaced.basJ"
    '=======================================
   ' _______________________________________
   '/OPEN Files for input and Output        \
    open CONVERT$+Fixed$ for OUTPUT as #11
    open CONVERT$+Scaned$ for INPUT as #10
   '\________________________________________/
   ' __________________________________________________________
   '/Check and space repair each line PB Code xx$ Line         \
    do until EOF(#10)
        line input #10,xx$
        restore   [SPACEitDATA]
        ' ___________________________________________________________
        '/Space it Out Data: any operator or divider you can think of\
        [SPACEitDATA]
         data "," , "(" , ")" , "=" , "*" , "-" , "+" , "?", "&"
         data "^" , "#" , "<" , ">" , ";", ":" ,"%", "@", "endit" 
        '\__________________________________________________________/
        '_______________________________________
        do 'Check for This Data Item in the Line\
            read Item$: if Item$="endit" then exit do
           '___________________________________________
            Z=1 'Check until multi Items in line spaced\
            do until Z=0 'Item$ not in line remander    \
            '--------------------------------------------
                Z = INSTR(xx$,Item$,Z) 'check for item
                '---------------------
                if Z=0 then exit do         'item not found
                Y3$=trim$(mid$(xx$,Z+1))    'right side of line trimed
                Y1$=Rtrim$(Left$(xx$,Z-1))  'left side of line part right trimed
                if Item$ ="#" then
                    if mid$(Y1$,len(Y1$),1)<>space$(1) then
                        Y2$=space$(1)+Item$ 'no space before Item$
                    else
                        Y2$=Item$
                    end if
                else
                    Y2$=space$(1)+Item$+space$(1)
                end if
                xx$=Y1$+Y2$
                Z=len(xx$)+1  'reset Z for continuing line search
                xx$=xx$+Y3$ 'repaired line with space seperators
            '----------------------
            loop '
           '\___until_Z=0_indicates_all_items_replaced___/
        loop until Item$ = "endit"
       '\___Data_Restored_For_Next_Line___________________/
       xx$=One.Space.For.Two$(xx$)
       if len(xx$)>0 then print #11,"' "+xx$+" '"
    loop 'for each PB code line
   '\___________________________________________________________/
   ' _________________
   '/Close OPEN Files \
        close #11
        close #10
   '\________________/

' __________________________________________________
'/Save to Controlling Text File                     \
    call Record.Repaired.Code
'\___________[structureREMOVElines]_________________/
 Err$="{{ RUN JB Program Again! }}"
'___________________________________________________
goto [Error.Handler]
'___________________________________________________
[structure.REMOVE.lines] Skip=Skip+1
Err$="M [structure.REMOVE.lines]"+"<"+str$(Found-Skip)+">"
call logit space$(Ln)+Err$
print tab(Ln);Err$
'________________________________________
If Found>Skip then goto [structure.CONST]
'=======================================
    ' ____________________________________________________________________
    '/SETUP Variables                                                     \
      SUBOFF=0
      Scaned$=Fixed$
      Fixed$=InFile$+".05.Removed.basJ"
    '\____________________________________________________________________/
    ' _____________________________________________________________________
    '/                                                                     \
     open CONVERT$+"VV-"+InFile$+".UnNeededRemoved.TXT" for output as #12: close #12
     open CONVERT$+Fixed$ for OUTPUT as #11
     open CONVERT$+Scaned$ for INPUT as #10
    '\_____________________________________________________________________/
    do until eof(#10)
        line input #10,test$
        test$=RemoveLines$ (test$) 'removes lines with READ in DATA
        if len(test$)>0 then
          print #11,test$
        end if
    loop
   ' _________________
   '/Close OPEN Files \
        close #11
        close #10
   '\_________________/

' __________________________________________________
'/Save to Controlling Text File                     \
    call Record.Repaired.Code
'\__________[structureCONST]________________________/
 Err$="{{ RUN JB Program Again! }}"
'____________________________________________
 goto [Error.Handler]
'_____________________________________
function RemoveLines$ (test$)
restore [DATArestore]
[DATArestore]
    DATA " #CONSOLE ON "," #REGISTER "," DEFLNG "," #RESOURCE "
    DATA " DECLARE SUB "," DECLARE FUNCTION "," #COMPILE EXE "
    DATA " #DEBUG ERROR "," MACRO ","ERRCLEAR","endit" 'here data

    while Remove$<>"endit"
        read Remove$: Remove$=lower$(Remove$) 'PB Lines were converted to lower case
        Z=instr(test$,Remove$)
        if Z>0 then  'Remove Command
            Y1$=trim$(left$(test$,Z)): Y2$=""
            if right$(Y1$,1)=":" then Y1$=trim$(left$(Y1$,len(Y1$)-1))
            if Y1$="'" then Y1$=""
            Z=instr(test$,":",Z)
            if Z>0 then Y2$=trim$(mid$(test$,Z+1))
            if Y2$="'" then Y2$=""
            open CONVERT$+"VV-"+InFile$+".UnNeededRemoved.TXT" for APPEND as #12
                print #12,test$
            close #12
            if Len(Y1$)>0 and Len(Y2$)>0 then
                test$=Y1$+" : "+Y2$
            else
                test$=trim$(Y1$+Y2$)
            end if
            if len(test$)=0 then exit while
        end if
    wend
    RemoveLines$=test$ 'may be empty
end function
'____________________________________________
[structure.CONST] Skip=Skip+1
Err$="M [structure.CONST] <"+str$(Found-Skip)+">"
call logit space$(Ln)+Err$
print tab(Ln);Err$
'________________________________________
If Found>Skip then goto [REMOVE.alias.QUOTE]
'=======================================
    ' _________________________________________
    '/SETUP Variables                          \
        SUBOFF=0
        Find$=" const "
        Scaned$=Fixed$
        Fixed$=InFile$+".06.CONST.basJ"
    '\_________________________________________/
   ' _______________________________________________________________________
   '/OPEN Files for input and Output                                        \
      open CONVERT$+"WW-GLOBAL.Variable.Store.TXT" for output as #12: close #12
      open CONVERT$+Fixed$ for OUTPUT as #11
      open CONVERT$+Scaned$ for INPUT as #10
    '\_______________________________________________________________________/

    do until eof(#10)
        line input #10,xx$

        Z = INSTR(xx$,Find$)
        if Z>0 then
            ' ________________________________________
            '/ CONST found
            yy2$=mid$(xx$,Z+len(Find$)) 'right of line after construct
            Z1=instr(yy2$,"="): IF Z1=0 then goto [BAILonIF]
            Global$=trim$(left$(yy2$,Z1-1))
            xx$="' "+yy2$                    '
           ' _____________________________________________________
           '/Save for addition to Global Statements               \
            open CONVERT$+"WW_"+InFile$+".GLOBAL.TXT" for append as #12
                print #12,Global$
            close #12
           '\_____________________________________________________/
        end if
        [BAILonIF]
        print #11,xx$
    loop
   ' _________________
   '/Close OPEN Files \
        close #11
        close #10
   '\_________________/

' __________________________________________________
'/Save to Controlling Text File                     \
    call Record.Repaired.Code
'\________[REMOVEaliasQUOTE]________________________/
 Err$="{{ RUN JB Program Again! }}"
'____________________________________________
 goto [Error.Handler]
 '============================================

'____________________________________________
[REMOVE.alias.QUOTE] Skip=Skip+1
Err$="M [REMOVE.alias.QUOTE]<"+str$(Found-Skip)+">"
call logit space$(Ln)+Err$
print tab(Ln);Err$
'________________________________________
If Found>Skip then goto [CREATE.simple.GLOBALS]
'=======================================
    ' _________________________________________
    '/SETUP Variables                          \
        SUBOFF=0
        SUB1OFF=0
        Scaned$=Fixed$
        Fixed$=InFile$+".07.ALIAS.basJ"
    '\_________________________________________/
   ' ___________________________________________________________________
   '/OPEN Files for input and Output                                    \
      open CONVERT$+"VV-"+InFile$+".UnNeededRemoved.TXT" for APPEND as #12
      open CONVERT$+Fixed$ for OUTPUT as #11
      open CONVERT$+Scaned$ for INPUT as #10
    '\__________________________________________________________________/
    ' __________________________________________________________________
    '/Remove ALAIS and Quote$ (??) store in Record File                 \
    do until eof(#10)
        line input #10,xx$
        Find$=" ALIAS QUOTE$ (": Find$=lower$(Find$)
        Z=instr(xx$,Find$)
        '===========================
        if Z=0 then
        '--------------------------------------------------------------->
            print #11,xx$: xx$=""
        '--------------------------------------------------------------->
        else

            ' __________________________________________________________
            '/ extract Allias quote$ ()                                 \
            Y1$=left$(xx$,Z)
            Y2$=mid$(xx$,Z+1,(Len(Find$)))
            E=instr(xx$," )",Z)
            if E>0 then
                Y2$=mid$(xx$,Z+1,E-Len(Y1$)+1)
                Y3$=mid$(xx$,E+2)
            else
                Y3$="<error?>"
            end if
            print #12,Y2$
            xx$=One.Space.For.Two$((Y1$+Y3$))
            print #11,xx$: xx$=""
        '---------------------------------------------------------------->
        end if
        '=============================
    loop
    '\___________________________________________________________________/
   ' _________________
   '/Close OPEN Files \
        close #11
        close #10
        close #12
   '\_________________/

' __________________________________________________
'/Save to Controlling Text File                     \
    call Record.Repaired.Code
'\__________[Next.Operation]______________________/
 Err$="{{ RUN JB Program Again! }}"

'____________________________________________
'____________________________________________
 goto [Error.Handler]
'============================================
'____________________________________________
[CREATE.simple.GLOBALS] Skip=Skip+1
Err$="M [CREATE.simple.GLOBALS]<"+str$(Found-Skip)+">"
call logit space$(Ln)+Err$
print tab(Ln);Err$
'________________________________________
If Found>Skip then goto [Next.Operation]
'=======================================
    ' _________________________________________
    '/SETUP Variables                          \
        SUBOFF=0
        Find$=" global "
        Scaned$=Fixed$
        Fixed$=InFile$+".08.Global.basJ"
    '\_________________________________________/

   ' ___________________________________________________________________
   '/OPEN Files for input and Output                                    \
      open CONVERT$+"WW_PB_Lotto_Pool.BAS.GLOBAL.TXT" for append as #12
      open CONVERT$+Fixed$ for OUTPUT as #11
      open CONVERT$+Scaned$ for INPUT as #10
    '\__________________________________________________________________/
   ' __________________________________________________________________
   '/Find Globals,output, then input, then save as single Global       \
     do until eof(#10)
        line input #10,xx$
        Z1=instr(xx$," as global " ): Z2=instr(xx$,Find$)
        '==============================================
        if (Z1>0 or Z2=0) then 'or Z2=0
'        '--------------------------------------------------------------->
            print #11,xx$: xx$=""
        '--------------------------------------------------------------->
        else
            Z=instr(xx$,Find$)
            if Z>0 then
            '============================================================
            ' __________________________________________________________
            '/ Global found: create output, input File                  \
            open CONTROL$+InFile$+".Global.temp" for output as #f5
                Y1$=left$(xx$,Z)
                E=instr(xx$," : ",Z)
                Y3$=""
                if E>0 then 'colin divider
                    Y2$=mid$(xx$,Z+1,E-Len(Y1$)-1)
                    Y3$=mid$(xx$,E+1)
                    E=instr(xx$,Find$,E+2)
                    if E>0 then
                        Y3$="<ERROR>"+Y3$+"<ERROR>"
                        print
                        PRINT "Code has [global ???,?? : global ??] on same line"
                        print "Repair by creating two Global lines in:"
                        print Scaned$
                        Err$=Y3$: goto [Error.Handler]
                    end if
                else 'no colin divider
                    Y2$=mid$(xx$,Z+1)
                    Y3$=""
                end if
                print #f5,Y2$
            close #f5 'Global line saved for input
            if instr(Y1$," : ")>0 then print #11,Y1$ 'statements previous to Global on line
            open CONTROL$+InFile$+".Global.temp" for input as #f5
                input #f5, Global$: Global$=trim$(Global$) 'input first global
                'reduce=instr(Global$," as long")
                'if reduce>0 then Global$=trim$(left$(Global$,reduce))
                if right$(Global$,1)<>"'" then Global$=Global$+" '"
                print #11,"' "+Global$
                do until eof(#f5)
                    input #f5, Global$: Global$=trim$(Global$) 'input
                    'reduce=instr(Global$," as long")
                    'if reduce>0 then Global$=trim$(left$(Global$,reduce))
                    if right$(Global$,1)<>"'" then Global$=Global$+" '"
                    print #11,"' global "+Global$
                loop
            close #f5
            '================================================
            end if
        '---------------------------------------------------------------->
        end if
        '=============================
     loop
    '\___________________________________________________________________/

   ' _________________
   '/Close OPEN Files \
      close #10
      close #11
      close #12
   '\_________________/
' __________________________________________________
'/Save to Controlling Text File                     \
    call Record.Repaired.Code
'\__________[Next.Operation]______________________/
 Err$="{{ RUN JB Program Again! }}"
'________________________________
goto [Error.Handler]
'________________________________
junk=0 'needed to prevent weird syntax error
'_______________________________________________________________________
[Next.Operation] 'place experiment code below here, found will > skip
'=======================================================================
junk=0 'needed to prevent weird syntax error when two labels are together
'========================================================================
' ______________________________________________________
'/END OF THIS PROGRAM, MORE STRUCTURAL WORK NEEDED BE IT\
'|FOR EITHER PYTHON OR JUST BASIC, DO NOT RUN AS EXE, IT |
'|IS CONSTRUCTED TO FIX CODE PROBLEMs AS ENCOUNTERED NEXT|
'|LOAD: [B-prep_Code TranslatePB-jb.basJ] to Continue    |
'|making changes to the PB code. It will use             |
'|[AB_Scaned-Code.txt] to capture the PB File Name.      |
'========================================================
'______________________________________________________________________________|
[PRE.A.translatorOUTPUTcompleted] 'final run will have Found>Skip
print "  _____________________________________________________  "
print " / Preparation .A. for Next Translating Code Complete! \ "
print "| TO CONTINUE TRANSLATING Power Basic, Load into the    |"
print "| JUST BASIC Editor [BB-prep_Code Translate PB-jb.basJ] |"
print "| Then RUN Program in Editor                            |"
print " \_____________________________________________________/ "
' __________________________________________
'/Setup files for saving completed prep AA  \
Scaned$=CONVERT$+Fixed$
Fixed$="BB."+InFile$
open "Load Last Translation.TXT" for append as #1
    print #1, Fixed$
close #1
'\__________________________________________/
   ' ___________________________________________________________________
   '/Save prepared file to Main Folder                                  \
      open Fixed$ for OUTPUT as #11
      open Scaned$ for INPUT as #10
    '\__________________________________________________________________/
   ' __________________________________________________________________
   '/Find Globals,output, then input, then save as single Global       \
     do until eof(#10)
        line input #10,xx$
        print #11,xx$
    loop
   ' _________________
   '/Close OPEN Files \
      close #10
      close #11
   '\_________________/
    '___________________________________________________________________
    [CONVERT.KILL.BASJ.FILES]
    dim info$(1,1) 'dim needed for info to gather file information
    files DefaultDir$+"\!CONVERT", "*.BASJ", info$() 'checks for BAS files
    Number=val(info$(0,0))
    if Number>0 then
        for F=1 to Number
            kill CONVERT$+info$(F,0)
        next F
    end if

'_________________________________________________________
[Error.Handler] 'NOTIFICATION OF END OF EXECUTION OR ERROR \
'\__Place SUB OR FUNCTION CALLS here only when no error!__/

    if Err>0 then
        print
        print " ___________________________________________"
        print "/          ERROR MESSAGE                    "
        if Err$<>"" then print "{"+Err$+"}"
        print "Error number is {";Err;"}"
        print "\__________END OF MESSAGE___________________"
    else
        print
        print " ___________________________________________"
        print "/          LAST PROCEDURE                   "
        print " {"+Err$+"}"
        print "\___________OR MESSAGE______________________"

       if Found>Skip then
            Ln=1: call logit "[END OF AA PROGRAM EXECUTION]"
        print " ___________________________________________"
        print "/          OUTPUTED FILE                    "
        print "   Program has Returned the Translated      "
        print "   Code to Program ["+Fixed$+"]"
        print "\______________THE_END______________________"
        end if
    end if


' __________________________________________________________________
'/  PROPER END TO PROGRAM EXECUTION AND ERROR HANDLING              \
                    END                                             '|
'|  3 RETURN without GOSUB                                           |
'|  4 Read past end of data                                          |
'|  8 Branch label not found                                         |
'|  9 Subscript out of range                                         |
'|  11 Division by zero                                              |
'|  53 OS Error: The system cannot find the file specified.          |
'|  58 OS Error: Cannot create a file when that file already exists. |
'|  55 Error opening file                                            |
'|  52 Bad file handle                                               |
'|  62 Input past end of file                                        |
'|                                                                   |
'\____________START OF FUNCTIONS AND SUBROTINES______________________/
'__________________________________________________
sub Record.Repaired.Code 'Fixed,CONVERT$ are Global
' __________________________________________________
'/Save to Controlling Text File                     \
open CONVERT$+"AA.Scaned.Code.txt" for append as #f2
    print #f2,Fixed$ 'last file created or repaired
close #f2
'\__________________________________________________/
end sub
'__________________________
[LOGtoCONTROLprocessedFILE]
sub logit itlog$
    open CONVERT$+"AA.PB to JB.log.TXT" for APPEND as #f1
        print #f1,SPACE$(L)+itlog$
    close #f1
end sub
'_______________________
FUNCTION Ltrim$(String$)
    do until String$=Trim$(String$)
        if trim$(String$)="" then String$="": exit do
        If left$(String$,1)=space$(1) then String$=mid$(String$,2) else exit do
    loop
    Ltrim$=String$
end function
'_______________________
FUNCTION Rtrim$(String$)
    do until String$=Trim$(String$)
        if trim$(String$)="" then String$="": exit do
        If Right$(String$,1)=space$(1) then
            String$=mid$(String$,1,len(String$)-1)
        else
            exit do
        end if
    loop
    Rtrim$=String$
end function
'________________________________________________________________
FUNCTION InsideQuotes(byref xx$,Z) 'closes open quotes
Err$="F InsideQuotes(byref xx$,Z)" 'Move past double quotes in xx$
if SUBOFF=0 then
    Ln=Ln+4
    print space$(Ln)+Err$
    call logit space$(Ln)+Err$
    Ln=Ln-4
    SUBOFF=SUBOFF+1
end if

     IF  Z = 0 THEN EXIT FUNCTION  'Z must be >0 to search for inside Quotes
     Y = 1 :  X = 1
     DO UNTIL  Y = 0
        Y = INSTR(xx$,CHR$(34), X)
        IF  Y > 0 THEN 'first quote found
              X =  Y + 1
              W = INSTR(xx$,CHR$(34), X)
             IF  W > 0 THEN 'closing quote found
                  X =  W + 1
                 IF  Z >  Y AND  Z <  W THEN 'return next position outside of quotes
                     InsideQuotes =  X
                     EXIT FUNCTION
                 END IF
             else 'closing Quote not found add Quote
                xx$= xx$+CHR$(34)
                Y = 1: X = 1
             END IF
         END IF
     LOOP
END FUNCTION
'_______________________________________________________
FUNCTION One.Space.For.Two$(two$)
Err$="F One.Space.For.Two$(two$)"
if SUB1OFF=0 then
    Ln=Ln+4
    print space$(Ln)+Err$
    call logit space$(Ln)+Err$
    Ln=Ln-4
    SUB1OFF=SUB1OFF+1
end if
    ' _________________________________________________
    '/ Eliminate two space gaps and empty lines        \
    two$=trim$(two$): Yes=1
    do until Yes=0
        Yes=instr(two$,space$(2))
        if Yes>0 then
            Y2$=trim$(mid$(two$,Yes)) 'right side
            Yes=Yes-1
            Y1$=left$(two$,Yes)  'left side
            two$=trim$(Y1$+space$(1)+Y2$) 'reduced to one space
        end if
    loop
    One.Space.For.Two$=two$
    '\---------------------------------------------------/
end Function
'=======================================















































































































































































































































































































































































































































































